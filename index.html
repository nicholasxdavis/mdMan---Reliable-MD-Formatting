<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mdMan - Batch Markdown to PDF Course Formatter</title>
    <meta name="description" content="A powerful batch processor to convert Markdown files into a single, professional PDF course book.">
    <link rel="icon" type="image/svg+xml" href="img/md.svg">
    <meta property="og:image" content="img/banner.png">

    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

    <script src="https://unpkg.com/@pdf-lib/fontkit/dist/fontkit.umd.min.js"></script>
    
    <script src="https://unpkg.com/lucide@latest"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@vercel/geist@1.3.0/dist/fonts/geist-sans/variable/geist-sans.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">


    <style>
        /* Base font */
        body {
            font-family: 'Geist Sans', 'Poppins', sans-serif;
            background-color: #f7f8fa; /* Cleaner, brighter bg */
        }

        /* Drag-over effect */
        #drop-zone.drag-over {
            border-style: solid;
            border-color: #268ca7; /* NEW: Theme color */
            background-color: #f0f9fa; /* NEW: Theme color light */
        }

        /* PDF Output Styling (v2 - "Wealth Course" Theme) 
          NOTE: This CSS is now only for the *hidden render area* if it
          were to be used. The actual PDF styling is now controlled
          by the pdf-lib logic in JavaScript.
        */
        #pdf-content {
            --theme-color: #268ca7; /* NEW: Default theme color */
            --font-family-serif: 'Times New Roman', Times, serif;
            --font-family-sans: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            --font-size-small: 10px;
            --font-size-medium: 12px;
            --font-size-large: 14px;
            font-family: var(--font-family-main);
            font-size: var(--font-size-main);
            color: #333; /* Softer black */
            line-height: 1.7; /* More breathing room */
        }
        .pdf-title-page { display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; height: 95vh; page-break-after: always; }
        .pdf-title-page .logo { max-width: 200px; max-height: 150px; object-fit: contain; margin-bottom: 2.5rem; }
        .pdf-title-page h1 { font-size: 2.8rem; font-weight: 800; color: var(--theme-color); margin-bottom: 0.75rem; line-height: 1.2; }
        .pdf-title-page h2 { font-size: 1.6rem; font-weight: 500; color: #374151; }
        
        .pdf-main-content h1 { 
            font-size: 2.2rem; 
            font-weight: 700; 
            color: var(--theme-color); 
            border-bottom: 2px solid var(--theme-color); 
            padding-bottom: 0.5rem; 
            margin-top: 2.5rem; 
            margin-bottom: 1.5rem; 
            page-break-before: always; 
        }
        .pdf-main-content h1:first-of-type { page-break-before: auto; margin-top: 0; }
        
        .pdf-main-content h2 { 
            font-size: 1.75rem; 
            font-weight: 600; 
            color: #111827; /* Darker for hierarchy */ 
            margin-top: 2.5rem; 
            margin-bottom: 1rem; 
            page-break-after: avoid; 
        }
        .pdf-main-content h3 { 
            font-size: 1.4rem; 
            font-weight: 600; 
            color: #374151; /* Dark gray */ 
            margin-top: 2rem; 
            margin-bottom: 0.75rem; 
            page-break-after: avoid; 
        }
        .pdf-main-content p { 
            margin-bottom: 1.25rem; 
            text-align: justify; 
        }
        .pdf-main-content ul, .pdf-main-content ol { margin-bottom: 1.25rem; padding-left: 1.75rem; }
        .pdf-main-content li { margin-bottom: 0.75rem; }
        
        /* Key "Pull-Quote" Styling */
        .pdf-main-content blockquote { 
            margin: 1.5rem 0; 
            padding: 1rem 1.5rem; 
            border-left: none;
            background-color: #f0f9fa; /* NEW: Theme color light */
            border-radius: 8px; /* NOTE: This is PDF-internal, keeping as-is */
            color: #374151; 
            font-style: italic; 
        }
        .pdf-main-content blockquote p {
            margin-bottom: 0;
        }

        .pdf-main-content pre { background-color: #f0f9fa; /* NEW: Theme color light */ padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin-bottom: 1.25rem; }
        .pdf-main-content code { font-family: 'Courier New', Courier, monospace; background-color: rgba(38, 140, 167, 0.1); /* NEW: Theme color lightest */ padding: 0.125rem 0.25rem; border-radius: 0.25rem; }
        .pdf-main-content pre code { background-color: transparent; padding: 0; border-radius: 0; }
        
        .pdf-main-content table { width: 100%; border-collapse: collapse; margin-bottom: 1.25rem; }
        .pdf-main-content th, .pdf-main-content td { border: 1px solid #dee2e6; padding: 0.75rem; text-align: left; }
        .pdf-main-content th { background-color: #f0f9fa; /* NEW: Theme color light */ font-weight: 600; }
        
        .pdf-main-content a { color: var(--theme-color); text-decoration: none; border-bottom: 1px dotted var(--theme-color); }
        .pdf-main-content a:hover { text-decoration: underline; border-bottom: 1px solid var(--theme-color); }

        /* Premium Image Styling */
        .pdf-main-content img { 
            max-width: 100%; 
            height: auto; 
            border-radius: 8px; 
            margin-top: 1rem; 
            margin-bottom: 1rem; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        
        .pdf-footer { 
            text-align: center; 
            font-size: 0.8rem; 
            color: #777; 
            margin-top: 2.5rem; 
            padding-top: 1rem; 
            border-top: 1px solid #e5e7eb; 
        }
        
        /* Loading Spinner */
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #268ca7; /* NEW: Theme color */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modal Styling */
        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-content {
            transition: all 0.25s ease;
            max-height: 90vh;
        }

        /* NEW: Simple Toggle Switch CSS */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #268ca7;
        }
        input:focus + .slider {
            box-shadow: 0 0 1px #268ca7;
        }

        /* === COLOR CIRCLE STYLING === */
        .color-circle {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-circle:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(38, 140, 167, 0.15);
        }

        .color-circle input[type="color"] {
            opacity: 0;
            width: 48px;
            height: 48px;
            border: none;
            cursor: pointer;
        }

        .color-circle .circle-border {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid #d1d5db;
            pointer-events: none;
            transition: border-color 0.3s ease;
        }

        .color-circle:hover .circle-border {
            border-color: #268ca7;
        }

        .color-circle input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-circle input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }
        /* Ensure the color input fully fills the circle with no white spacing */
        .color-circle input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            padding: 0;
            border: none;
            border-radius: 50%;
            width: 3rem; /* matches w-12 */
            height: 3rem; /* matches h-12 */
            overflow: hidden;
            background: none;
        }
        .color-circle input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }
        /* Custom visual circle for robust cross-browser display */
        .color-visual {
            width: 100%;
            height: 100%;
            border-radius: 9999px;
        }
        input:checked + .slider:before {
            transform: translateX(16px);
        }

    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    <header class="sticky top-0 z-40 w-full bg-white shadow-sm border-b border-[#1a1a1a]/[0.15]">
        <div class="container mx-auto p-4 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <img src="img/md.svg" alt="mdMan Logo" class="h-8 w-8" onerror="this.outerHTML='<i data-lucide=\'package\' class=\'h-8 w-8 text-[#268ca7]\'></i>'">
                <span class="text-2xl font-light text-gray-800">mdMan</span>
            </div>
            
            <nav class="hidden lg:flex items-center space-x-6">
                <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Homepage</a>
                
                <div class="relative group">
                    <button class="text-gray-600 hover:text-[#268ca7] transition font-medium flex items-center space-x-1 focus:outline-none">
                        <span>Tools</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                    </button>
                    <div class="absolute z-10 w-56 mt-2 bg-white rounded-xl shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 ease-in-out transform -translate-y-2 group-hover:translate-y-0 border border-[#1a1a1a]/[0.15]">
                        <div class="p-2">
                            <a href="#" class="block px-4 py-2 text-sm text-white bg-[#268ca7] rounded-3xl font-medium">Course Formatting</a>
                            <a href="#" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-[#268ca7] rounded-3xl transition">Ebook Formatting</a>
                            <a href="#" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-[#268ca7] rounded-3xl transition">Storybook Formatting</a>
                            <a href="#" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-[#268ca7] rounded-3xl transition">Document Formatting</a>
                        </div>
                    </div>
                </div>

                <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Github</a>
                <a href="https://buymeacoffee.com/galore" target="_blank" rel="noopener noreferrer" class="text-gray-600 hover:text-[#268ca7] transition font-medium inline-flex items-center">
                    <span>Support</span>
                    <i data-lucide="heart" class="w-4 h-4 text-[#92c5d3] ml-1"></i>
                </a>
                <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Help</a>
            </nav>

            <button id="mobile-menu-button" class="lg:hidden p-2 rounded-3xl hover:bg-gray-100 text-gray-700 hover:text-[#268ca7] transition">
                <i data-lucide="menu" class="w-6 h-6"></i>
            </button>
        </div>
        
        <div id="mobile-menu" class="hidden lg:hidden container mx-auto p-4 border-t border-gray-100">
            <nav class="flex flex-col space-y-4">
                <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Homepage</a>
                
                <div>
                    <span class="text-gray-500 font-medium text-sm uppercase">Tools</span>
                    <div class="flex flex-col mt-2 space-y-3 pl-4">
                        <a href="#" class="text-white bg-[#268ca7] -ml-2 px-2 py-1 rounded-3xl font-medium">Course Formatting</a>
                        <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Ebook Formatting</a>
                        <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Storybook Formatting</a>
                        <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Document Formatting</a>
                    </div>
                </div>

                <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Github</a>
                <a href="https://buymeacoffee.com/galore" target="_blank" rel="noopener noreferrer" class="text-gray-600 hover:text-[#268ca7] transition font-medium inline-flex items-center">
                    <span>Support</span>
                    <i data-lucide="heart" class="w-4 h-4 text-[#92c5d3] ml-1"></i>
                </a>
                <a href="#" class="text-gray-600 hover:text-[#268ca7] transition font-medium">Help</a>
            </nav>
        </div>
    </header>

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <i data-lucide="file-text" class="w-12 h-12 mx-auto text-[#268ca7]"></i>
            <h1 class="text-4xl font-light text-gray-800 mt-2">Course Formatting</h1>
            <p class="text-lg text-gray-600 mt-2">Upload multiple Markdown files and process them into a single .zip.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">

            <div class="lg:col-span-7 space-y-8">
                
                <div class="bg-white p-6 rounded-3xl shadow-lg border border-[#1a1a1a]/[0.15]">
                    <h2 class="flex items-center text-xl font-semilight text-gray-700 mb-4">
                        <i data-lucide="upload-cloud" class="w-5 h-5 mr-2 text-[#268ca7]"></i>
                        1. Upload Files
                    </h2>
                    
                    <div id="toast-container" class="mb-4 p-3 rounded-2xl hidden" style="background: linear-gradient(135deg, rgba(146, 197, 211, 0.65), rgba(183, 215, 223, 0.65)); border: 1px solid rgba(123, 179, 193, 0.5); backdrop-filter: blur(10px);">
                        <div class="flex items-start space-x-2">
                            <i id="toast-icon" data-lucide="lightbulb" class="w-4 h-4 mt-0.5 flex-shrink-0" style="color: #353535;"></i>
                            <div class="text-sm" style="color: #353535;">
                                <p id="toast-title" class="font-medium mb-1">Suggestion:</p>
                                <p id="toast-message">Use numbered prefixes in your filenames for automatic ordering:</p>
                                <p id="toast-example" class="font-mono text-xs mt-1 px-2 py-1 rounded" style="background-color: rgba(168, 209, 220, 0.4); color: #353535;">01 - Introduction.md, 02 - Getting Started.md, 03 - Advanced Topics.md</p>
                            </div>
                        </div>
                    </div>
                    
                    <input type="file" id="file-input" multiple accept=".md,.markdown" class="hidden">
                    <div id="drop-zone" class="border-2 border-dashed border-gray-300 rounded-3xl p-8 text-center cursor-pointer hover:border-[#268ca7] hover:bg-f0f9fa transition">
                        <i data-lucide="file-up" class="w-12 h-12 mx-auto text-gray-400"></i>
                        <p class="mt-2 text-gray-600">Drag & drop .md files here</p>
                        <p class="text-sm text-gray-500 mt-1">or</p>
                        <button id="browse-files" class="mt-2 bg-gray-200 text-gray-800 font-semilight py-1 px-3 rounded-3xl text-sm hover:bg-gray-300 transition">
                            Browse Files
                        </button>
                    </div>

                    <div id="file-list-header" class="flex justify-between items-center mt-6 mb-2 hidden">
                        <h3 class="text-lg font-semilight text-gray-600">File Queue</h3>
                        <button id="clear-queue" class="text-sm text-red-500 hover:text-red-700 font-medium flex items-center">
                            <i data-lucide="trash-2" class="w-4 h-4 mr-1"></i>
                            Clear All
                        </button>
                    </div>
                    <div id="file-list" class="space-y-2 max-h-96 overflow-y-auto">
                        <div id="empty-queue-message" class="text-center text-gray-500 p-4">
                            <i data-lucide="inbox" class="w-8 h-8 mx-auto text-gray-400"></i>
                            <p class="mt-2">Your file queue is empty.</p>
                        </div>
                        </div>
                </div>

                <div class="bg-white p-6 rounded-3xl shadow-lg border border-[#1a1a1a]/[0.15]">
                    <h2 class="flex items-center text-xl font-semilight text-gray-700 mb-4">
                        <i data-lucide="settings-2" class="w-5 h-5 mr-2 text-[#268ca7]"></i>
                        2. Global Settings
                    </h2>
                    <p class="text-sm text-gray-500 mb-4">
                        These settings apply to all files unless overridden. Settings are saved locally.
                    </p>
                    
                    <div class="flex space-x-2 mb-4">
                        <input type="file" id="import-settings-input" class="hidden" accept="application/json">
                        <button id="import-settings-btn" class="flex-1 bg-gray-100 text-gray-700 font-medium py-2 px-3 rounded-3xl border border-gray-300 hover:bg-gray-200 transition text-sm flex items-center justify-center space-x-2">
                            <i data-lucide="upload" class="w-4 h-4"></i>
                            <span>Import</span>
                        </button>
                        <button id="export-settings-btn" class="flex-1 bg-gray-100 text-gray-700 font-medium py-2 px-3 rounded-3xl border border-gray-300 hover:bg-gray-200 transition text-sm flex items-center justify-center space-x-2">
                            <i data-lucide="download" class="w-4 h-4"></i>
                            <span>Export</span>
                        </button>
                    </div>
                    
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div class="space-y-4 p-4 border border-gray-200 rounded-3xl">
                            <h3 class="font-medium text-lg text-gray-600">Branding</h3>
                            <div>
                                <label for="course-title" class="block text-sm font-medium text-gray-700">Course Title</label>
                                <input type="text" id="course-title" value="My Awesome Wealth Course" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                            </div>
                            <div>
                                <label for="instructor-name" class="block text-sm font-medium text-gray-700">Instructor Name</label>
                                <input type="text" id="instructor-name" value="Dr. Jane Doe" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                            </div>
                            <div>
                                <label for="logo-url" class="block text-sm font-medium text-gray-700">Logo URL (Optional)</label>
                                <input type="text" id="logo-url" placeholder="https://..." class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                            </div>
                            <div>
                                <label for="footer-text" class="block text-sm font-medium text-gray-700">Footer Text</label>
                                <input type="text" id="footer-text" value="Â© 2025 Wealth Builders Inc." class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                            </div>
                            <div>
                                <label for="zip-filename" class="block text-sm font-medium text-gray-700">.zip Filename</label>
                                <input type="text" id="zip-filename" value="wealth-course-batch" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                            </div>
                            <div>
                                <label for="course-type" class="block text-sm font-medium text-gray-700">Course Type</label>
                                <select id="course-type" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                    <option value="wealth" selected>Wealth Course (Default)</option>
                                    <option value="education">Education</option>
                                    <option value="lecture">Lecture</option>
                                    <option value="general">General</option>
                                </select>
                            </div>
                            
                            <div class="flex items-center justify-between pt-2">
                                <label for="include-toc" class="text-sm font-medium text-gray-700">Table of Contents Page
                                    <span class="block text-xs text-gray-500">Uses file starting with "00 - "</span>
                                </label>
                                <label class="switch">
                                    <input type="checkbox" id="include-toc" class="setting-input">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            </div>

                        <div class="space-y-4 p-4 border border-gray-200 rounded-3xl">
                            <h3 class="font-medium text-lg text-gray-600">Formatting</h3>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Course Colors</label>
                                <div class="flex space-x-3 mt-2">
                                    <!-- Main Color Circle -->
                                    <div class="flex flex-col items-center space-y-1 color-circle">
                                        <label class="text-xs text-gray-600 font-medium">Main</label>
                                        <div class="relative w-12 h-12">
                                            <div class="color-visual absolute inset-0"></div>
                                            <input type="color" id="theme-color-main" value="#268ca7" class="setting-input absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                                        </div>
                                    </div>

                                    <!-- Secondary Color Circle -->
                                    <div class="flex flex-col items-center space-y-1 color-circle">
                                        <label class="text-xs text-gray-600 font-medium">Secondary</label>
                                        <div class="relative w-12 h-12">
                                            <div class="color-visual absolute inset-0"></div>
                                            <input type="color" id="theme-color-secondary" value="#1e6a80" class="setting-input absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                                        </div>
                                    </div>

                                    <!-- Text Color Circle -->
                                    <div class="flex flex-col items-center space-y-1 color-circle">
                                        <label class="text-xs text-gray-600 font-medium">Text</label>
                                        <div class="relative w-12 h-12">
                                            <div class="color-visual absolute inset-0"></div>
                                            <input type="color" id="theme-color-text" value="#333333" class="setting-input absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                                        </div>
                                    </div>

                                    <!-- Background Color Circle -->
                                    <div class="flex flex-col items-center space-y-1 color-circle">
                                        <label class="text-xs text-gray-600 font-medium">Background</label>
                                        <div class="relative w-12 h-12">
                                            <div class="color-visual absolute inset-0"></div>
                                            <input type="color" id="theme-color-bg" value="#f7f8fa" class="setting-input absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                                        </div>
                                    </div>
                                </div>

                                <!-- Hidden inputs to store theme type -->
                                <input type="hidden" id="theme-type" value="wealth-course" class="setting-input">
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
                                <div>
                                    <label for="text-alignment" class="block text-sm font-medium text-gray-700">Text Alignment</label>
                                    <select id="text-alignment" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                        <option value="left" selected>Left</option>
                                        <option value="justify">Justify</option>
                                        <option value="center">Center</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="paragraph-spacing" class="block text-sm font-medium text-gray-700">Paragraph Spacing</label>
                                    <select id="paragraph-spacing" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                        <option value="compact">Compact</option>
                                        <option value="normal" selected>Normal</option>
                                        <option value="relaxed">Relaxed</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div>
                                <label for="font-family" class="block text-sm font-medium text-gray-700">Font Family</label>
                                <select id="font-family" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                    <option value="geist">Geist (Default)</option>
                                    <option value="lato">Lato</option>
                                    <option value="poppins">Poppins</option>
                                    <option value="montserrat">Montserrat (Variable)</option>
                                    <option value="oswald">Oswald (Variable)</option>
                                    <option value="rye">Rye</option>
                                    <option value="alumni">Alumni Collegiate</option>
                                    
                                    <option disabled>--- Geist (Specific) ---</option>
                                    <option value="geist-thin">Geist Thin</option>
                                    <option value="geist-extralight">Geist ExtraLight</option>
                                    <option value="geist-light">Geist Light</option>
                                    <option value="geist-regular">Geist Regular</option>
                                    <option value="geist-medium">Geist Medium</option>
                                    <option value="geist-semilight">Geist Semilight</option>
                                    <option value="geist-light">Geist light</option>
                                    <option value="geist-extralight">Geist Extralight</option>
                                    <option value="geist-black">Geist Black</option>
                                    
                                    <option disabled>--- Lato (Specific) ---</option>
                                    <option value="lato-light">Lato Light</option>
                                    <option value="lato-regular">Lato Regular</option>
                                    <option value="lato-light">Lato light</option>
                                    <option value="lato-black">Lato Black</option>
                                </select>
                            </div>
                            <div>
                                <label for="font-size" class="block text-sm font-medium text-gray-700">Base Font Size</label>
                                <select id="font-size" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                    <option value="small">Small (10px)</option>
                                    <option value="medium" selected>Medium (12px)</option>
                                    <option value="large">Large (14px)</option>
                                </select>
                            </div>
                            <div>
                                <label for="header-font-weight" class="block text-sm font-medium text-gray-700">Header Font Weight</label>
                                <select id="header-font-weight" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                    <option value="thin">Thin</option>
                                    <option value="extralight">Extra Light</option>
                                    <option value="light">Light</option>
                                    <option value="regular">Regular</option>
                                    <option value="medium">Medium</option>
                                    <option value="semibold" selected>Semi Bold</option>
                                    <option value="bold">Bold</option>
                                    <option value="extrabold">Extra Bold</option>
                                    <option value="black">Black</option>
                                </select>
                            </div>
                            <div class="mt-2">
                                <label for="include-page-numbers" class="inline-flex items-center space-x-2 cursor-pointer">
                                    <input type="checkbox" id="include-page-numbers" class="setting-input rounded mr-2">
                                    <span class="text-sm font-medium text-gray-700">Include Page Numbers</span>
                                </label>
                            </div>
                            <div class="mt-2">
                                <label for="heading-style-preset" class="block text-sm font-medium text-gray-700">Heading Style Preset</label>
                                <select id="heading-style-preset" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                    <option value="clean" selected>Clean</option>
                                    <option value="bold">Bold</option>
                                    <option value="minimalist">Minimalist</option>
                                </select>
                            </div>
                             
                            <div class="hidden">
                                <label for="style-preset" class="block text-sm font-medium text-gray-700">Style Preset</label>
                                <select id="style-preset" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]" disabled title="Style is set by pdf-lib logic">
                                    <option value="wealth-course" selected>pdf-lib Default</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-5">
                <div class="bg-white p-6 rounded-3xl shadow-lg sticky top-8 border border-[#1a1a1a]/[0.15]">
                    <h2 class="flex items-center text-xl font-semilight text-gray-700 mb-4">
                        <i data-lucide="zap" class="w-5 h-5 mr-2 text-[#268ca7]"></i>
                        3. Process Batch
                    </h2>
                    <p class="text-gray-600 mb-4">
                        Select your output format, then process all files in the queue.
                    </p>
                    
                    <div>
                        <label for="processing-mode" class="block text-sm font-medium text-gray-700">Processing Mode</label>
                        <select id="processing-mode" class="mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                            <option value="zip">Download as .zip (Multiple Files)</option>
                            <option value="single">Download as Single Combined PDF</option>
                        </select>
                    </div>

                    <button id="generate-batch" class="w-full bg-[#268ca7] text-white font-light py-3 px-6 rounded-3xl shadow-md hover:bg-[#1e6a80] transition duration-300 ease-in-out flex items-center justify-center space-x-2 disabled:opacity-50 mt-6" disabled>
                        <i data-lucide="package-check" class="w-5 h-5"></i>
                        <span id="batch-button-text">Start Batch Process</span>
                    </button>
                    
                    <div id="progress-area" class="mt-6 hidden">
                        <div class="flex justify-between mb-1">
                            <span class="text-base font-medium text-[#268ca7]">Batch Progress</span>
                            <span id="progress-text" class="text-sm font-medium text-[#268ca7]">0%</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div id="progress-bar" class="bg-[#268ca7] h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                        <p id="global-status" class="text-sm text-gray-600 mt-2 text-center"></p>
                    </div>

                    <div id="error-message" class="mt-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-3xl hidden">
                        <p><strong>Global Error:</strong> <span id="error-text"></span></p>
                    </div>
                </div>
            </div>

        </div>

        <div class="mt-8 bg-white p-4 md:p-8 rounded-3xl shadow-lg border border-[#1a1a1a]/[0.15]">
            <h2 class="flex items-center text-xl md:text-2xl font-light text-gray-800 mb-4 md:mb-6">
                <i data-lucide="route" class="w-6 h-6 mr-3 text-[#268ca7]"></i>
                Workflow Example
            </h2>
            <div class="relative">
                <div class="relative flex items-start space-x-3 md:space-x-5 p-2 md:p-4">
                    <div class="relative z-10 flex h-10 w-10 md:h-14 md:w-14 flex-shrink-0 items-center pt-1.5 md:pt-0">
                        <img src="img/obi.svg" alt="Obsidian Logo" class="h-8 w-8 md:h-12 md:w-12" onerror="this.outerHTML='<i data-lucide=\'file-text\' class=\'h-8 w-8 md:h-12 md:w-12 text-[#268ca7]\'></i>'">
                    </div>
                    <div class="min-w-0 flex-1 pt-0 md:pt-1.5">
                        <h3 class="text-md md:text-lg font-semilight text-gray-900">1. Create Content in Obsidian</h3>
                        <p class="mt-1 text-sm md:text-base text-gray-600">Use <strong class="font-medium text-gray-800">Obsidian</strong> as your central hub. Write content, gather research, and organize all your files into a single folder within your vault.</p>
                        <p class="mt-2 text-sm md:text-base text-gray-600">When ready, right-click that folder, choose "Show in system explorer," and copy the entire folder to an accessible location like your Desktop.</p>
                        <p class="mt-2 text-sm md:text-base text-gray-600">Note: AI models like Kimi K2 are great for writing initial content due to their large 256,000 token context windows.</p>
                    </div>
                </div>
    
                <div class="relative flex items-start space-x-3 md:space-x-5 p-2 md:p-4">
                    <div class="relative z-10 flex h-10 w-10 md:h-14 md:w-14 flex-shrink-0 items-center pt-1.5 md:pt-0">
                        <img src="img/cube.svg" alt="Cursor Logo" class="h-8 w-8 md:h-12 md:w-12" onerror="this.outerHTML='<i data-lucide=\'edit\' class=\'h-8 w-8 md:h-12 md:w-12 text-[#268ca7]\'></i>'">
                    </div>
                    <div class="min-w-0 flex-1 pt-0 md:pt-1.5">
                        <h3 class="text-md md:text-lg font-semilight text-gray-900">2. Edit & Refine with Cursor</h3>
                        <p class="mt-1 text-sm md:text-base text-gray-600">Next, open <strong class="font-medium text-gray-800">Cursor</strong> and start a new project. Find and select the folder you just copied from Obsidian. Now you can use AI to batch-edit all your Markdown files at once. Provide instructions like:</p>
                        <blockquote class="mt-3 p-3 bg-gray-50 border-l-4 border-[#268ca7] text-gray-700 rounded-r-3xl italic text-xs md:text-sm">
                            "Please rename all files using a numbered prefix in the format 01 - Name, 02 - Name, You can decide the starting point and the order of the sections, but arrange them so the flow makes sense. For example, if one section is about skill vs. luck and another section is aswell, place the following section logically after it to build on that idea."
                        </blockquote>
                        <p class="mt-3 text-sm md:text-base text-gray-600">You can also use Cursor to:</p>
                        <ul class="list-disc list-inside mt-2 pl-4 space-y-1 text-sm md:text-base text-gray-600">
                            <li>Proofread and edit content</li>
                            <li>Retone or reformat pages</li>
                            <li>Generate additional pages as needed</li>
                        </ul>
                    </div>
                </div>
    
                <div class="relative flex items-start space-x-3 md:space-x-5 p-2 md:p-4">
                    <div class="relative z-10 flex h-10 w-10 md:h-14 md:w-14 flex-shrink-0 items-center pt-1.5 md:pt-0">
                        <img src="img/md.svg" alt="mdMan Logo" class="h-8 w-8 md:h-12 md:w-12" onerror="this.outerHTML='<i data-lucide=\'package-check\' class=\'h-8 w-8 md:h-12 md:w-12 text-[#268ca7]\'></i>'">
                    </div>
                    <div class="min-w-0 flex-1 pt-0 md:pt-1.5">
                        <h3 class="text-md md:text-lg font-semilight text-gray-900">3. Process & Compile</h3>
                        <p class="mt-1 text-sm md:text-base text-gray-600">Bring your polished .md files to <strong class="font-medium text-gray-800">mdMan</strong>.</p>
                        <ul class="list-disc list-inside mt-2 pl-4 space-y-1 text-sm md:text-base text-gray-600">
                            <li>Drag and drop all your files into the queue.</li>
                            <li>Adjust the Global Settings to your liking (title, logo, theme).</li>
                            <li>Use the "Single Combined PDF" mode for one master file.</li>
                            <li>Process the batch and enjoy your premium, compiled course.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <div id="pdf-render-area" class="invisible absolute -top-full left-0 w-[210mm] overflow-hidden">
        <div id="pdf-content" class="p-[20mm]">
            </div>
    </div>

    <div id="pdf-render-area-combined" class="invisible absolute -top-full left-0 w-[210mm] overflow-hidden">
        </div>

    <div id="settings-modal" class="modal fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4 opacity-0 invisible">
        <div class="modal-content bg-white rounded-3xl shadow-2xl w-full max-w-4xl opacity-0 transform -translate-y-10 overflow-y-auto border border-[#1a1a1a]/[0.15]">
            <div class="flex justify-between items-center p-4 border-b">
                <h3 class="text-xl font-semilight text-gray-800">File-Specific Settings</h3>
                <button id="close-modal" class="text-gray-400 hover:text-gray-600">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            
            <div class="p-6">
                <p class="text-sm text-gray-600 mb-4">
                    You are editing settings for: <strong id="modal-file-name" class="text-gray-900"></strong>
                    <br>
                    These settings will override the global settings for this file only.
                </p>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <div class="space-y-4 p-4 border border-gray-200 rounded-3xl">
                        <h3 class="font-medium text-lg text-gray-600">Branding</h3>
                        <div>
                            <label for="modal-course-title" class="block text-sm font-medium text-gray-700">Course Title</label>
                            <input type="text" id="modal-course-title" class="mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                        </div>
                        <div>
                            <label for="modal-instructor-name" class="block text-sm font-medium text-gray-700">Instructor Name</label>
                            <input type="text" id="modal-instructor-name" class="mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                        </div>
                        <div>
                            <label for="modal-logo-url" class="block text-sm font-medium text-gray-700">Logo URL</label>
                            <input type="text" id="modal-logo-url" class="mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                        </div>
                        <div>
                            <label for="modal-footer-text" class="block text-sm font-medium text-gray-700">Footer Text</label>
                            <input type="text" id="modal-footer-text" class="mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                        </div>
                        <div class="flex items-center justify-between pt-2">
                            <label for="modal-include-toc" class="text-sm font-medium text-gray-700">Table of Contents Page
                                <span class="block text-xs text-gray-500">Uses file starting with "00 - "</span>
                            </label>
                            <label class="switch">
                                <input type="checkbox" id="modal-include-toc" class="setting-input">
                                <span class="slider"></span>
                            </label>
                        </div>
                        </div>

                    <div class="space-y-4 p-4 border border-gray-200 rounded-3xl">
                        <h3 class="font-medium text-lg text-gray-600">Formatting</h3>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Course Type</label>
                            <div class="flex space-x-3 mt-2">
                                <!-- Main Color Circle -->
                                <div class="flex flex-col items-center space-y-1">
                                    <label class="text-xs text-gray-600 font-medium">Main</label>
                                    <div class="relative">
                                        <input type="color" id="modal-theme-color-main" value="#268ca7" class="setting-input w-12 h-12 rounded-full border-2 border-gray-300 cursor-pointer shadow-sm hover:shadow-md transition-shadow">
                                            <div class="absolute inset-0 rounded-full border-2 border-gray-300 pointer-events-none"></div>
                                        </div>
                                    </div>

                                <!-- Secondary Color Circle -->
                                <div class="flex flex-col items-center space-y-1">
                                    <label class="text-xs text-gray-600 font-medium">Secondary</label>
                                    <div class="relative">
                                        <input type="color" id="modal-theme-color-secondary" value="#1e6a80" class="setting-input w-12 h-12 rounded-full border-2 border-gray-300 cursor-pointer shadow-sm hover:shadow-md transition-shadow">
                                            <div class="absolute inset-0 rounded-full border-2 border-gray-300 pointer-events-none"></div>
                                        </div>
                                    </div>

                                <!-- Text Color Circle -->
                                <div class="flex flex-col items-center space-y-1">
                                    <label class="text-xs text-gray-600 font-medium">Text</label>
                                    <div class="relative">
                                        <input type="color" id="modal-theme-color-text" value="#333333" class="setting-input w-12 h-12 rounded-full border-2 border-gray-300 cursor-pointer shadow-sm hover:shadow-md transition-shadow">
                                            <div class="absolute inset-0 rounded-full border-2 border-gray-300 pointer-events-none"></div>
                                        </div>
                                    </div>

                                <!-- Background Color Circle -->
                                <div class="flex flex-col items-center space-y-1">
                                    <label class="text-xs text-gray-600 font-medium">Background</label>
                                    <div class="relative">
                                        <input type="color" id="modal-theme-color-bg" value="#f7f8fa" class="setting-input w-12 h-12 rounded-full border-2 border-gray-300 cursor-pointer shadow-sm hover:shadow-md transition-shadow">
                                            <div class="absolute inset-0 rounded-full border-2 border-gray-300 pointer-events-none"></div>
                                        </div>
                                    </div>
                            </div>

                            <!-- Hidden inputs to store theme type -->
                            <input type="hidden" id="modal-theme-type" value="wealth-course" class="setting-input">
                        </div>
                        <div>
                            <label for="modal-font-family" class="block text-sm font-medium text-gray-700">Font Family</label>
                            <select id="modal-font-family" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                <option value="geist">Geist (Default)</option>
                                <option value="lato">Lato</option>
                                <option value="poppins">Poppins</option>
                                <option value="montserrat">Montserrat (Variable)</option>
                                <option value="oswald">Oswald (Variable)</option>
                                <option value="rye">Rye</option>
                                <option value="alumni">Alumni Collegiate</option>
                                
                                <option disabled>--- Geist (Specific) ---</option>
                                <option value="geist-thin">Geist Thin</option>
                                <option value="geist-extralight">Geist ExtraLight</option>
                                <option value="geist-light">Geist Light</option>
                                <option value="geist-regular">Geist Regular</option>
                                <option value="geist-medium">Geist Medium</option>
                                <option value="geist-semilight">Geist Semilight</option>
                                <option value="geist-light">Geist light</option>
                                <option value="geist-extralight">Geist Extralight</option>
                                <option value="geist-black">Geist Black</option>
                                
                                <option disabled>--- Lato (Specific) ---</option>
                                <option value="lato-light">Lato Light</option>
                                <option value="lato-regular">Lato Regular</option>
                                <option value="lato-light">Lato light</option>
                                <option value="lato-black">Lato Black</option>
                            </select>
                        </div>
                        <div>
                            <label for="modal-font-size" class="block text-sm font-medium text-gray-700">Base Font Size</label>
                            <select id="modal-font-size" class="mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                <option value="small">Small (10px)</option>
                                <option value="medium">Medium (12px)</option>
                                <option value="large">Large (14px)</option>
                            </select>
                        </div>
                        <div>
                            <label for="modal-header-font-weight" class="block text-sm font-medium text-gray-700">Header Font Weight</label>
                            <select id="modal-header-font-weight" class="setting-input mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]">
                                <option value="thin">Thin</option>
                                <option value="extralight">Extra Light</option>
                                <option value="light">Light</option>
                                <option value="regular">Regular</option>
                                <option value="medium">Medium</option>
                                <option value="semibold">Semi Bold</option>
                                <option value="bold">Bold</option>
                                <option value="extrabold">Extra Bold</option>
                                <option value="black">Black</option>
                            </select>
                        </div>
                        <div class="hidden">
                            <label for="modal-style-preset" class="block text-sm font-medium text-gray-700">Style Preset</label>
                            <select id="modal-style-preset" class="mt-1 block w-full border-gray-300 rounded-3xl shadow-sm focus:ring-[#268ca7] focus:border-[#268ca7]" disabled>
                                <option value="wealth-course" selected>pdf-lib Default</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex justify-between items-center p-4 bg-gray-50 border-t rounded-b-3xl">
                <button id="clear-overrides" class="text-sm text-red-600 hover:text-red-800 font-medium">
                    Clear Overrides
                </button>
                <div>
                    <button id="cancel-modal" class="bg-white text-gray-700 font-medium py-2 px-4 rounded-3xl border border-gray-300 hover:bg-gray-50 transition mr-2">
                        Cancel
                    </button>
                    <button id="save-overrides" class="bg-[#268ca7] text-white font-medium py-2 px-4 rounded-3xl shadow-sm hover:bg-[#1e6a80] transition">
                        Save Overrides
                    </button>
                </div>
            </div>
        </div>
    </div>

    <footer class="w-full border-t border-gray-200 bg-white mt-12 border-t border-[#1a1a1a]/[0.15]">
        <div class="container mx-auto p-8 text-center text-gray-500 flex flex-col items-center space-y-4">
            <img src="https://www.blacnova.net/img/bn_black.png" alt="Blacnova Logo" class="h-10 opacity-70">
            <p class="text-sm">&copy; 2025 mdMan by Blacnova. All rights reserved.</p>
            <a href="https://buymeacoffee.com/galore" target="_blank" rel="noopener noreferrer" class="text-sm font-medium text-[#268ca7] hover:text-[#1e6a80] transition flex items-center space-x-1.5 px-4 py-2 rounded-3xl bg-gray-100 hover:bg-gray-200">
                <i data-lucide="coffee" class="w-4 h-4"></i>
                <span>Support Us</span>
            </a>
        </div>
    </footer>


    <script>
        /**
         * FormatterApp
         * Encapsulates all logic for the batch PDF formatter.
         *
         * REWRITE: Now uses pdf-lib instead of html2pdf.js.
         * UPDATE: Added dynamic font loading and TOC feature.
         */
        const FormatterApp = {
            // --- State ---
            fileQueue: [], // Stores { id, name, content, overrideSettings: null | {} }
            SETTINGS_KEY: 'mdToPdfSettingsV4', // Updated key for new version

            /**
             * === NEW: FONT MAP ===
             * Defines the local paths for all available font families.
             * Each family needs a 'regular', 'light', and 'italic' variant.
             * We use fallbacks (e.g., 'regular' for 'italic') if a variant is missing.
             */
            fontMap: {
                // Geist (Complete Set)
                'geist': {
                    regular: 'fonts/Geist-Regular.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-Regular.ttf' // Fallback
                },
                'geist-thin': {
                    regular: 'fonts/Geist-Thin.ttf',
                    light: 'fonts/Geist-Thin.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-Thin.ttf'
                },
                'geist-extralight': {
                    regular: 'fonts/Geist-ExtraLight.ttf',
                    light: 'fonts/Geist-ExtraLight.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-ExtraLight.ttf'
                },
                 'geist-light': {
                    regular: 'fonts/Geist-Light.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-Light.ttf'
                },
                'geist-regular': {
                    regular: 'fonts/Geist-Regular.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-Regular.ttf'
                },
                'geist-medium': {
                    regular: 'fonts/Geist-Medium.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-Medium.ttf'
                },
                'geist-semibold': {
                    regular: 'fonts/Geist-SemiBold.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-SemiBold.ttf'
                },
                'geist-bold': {
                    regular: 'fonts/Geist-Bold.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-Bold.ttf'
                },
                'geist-extrabold': {
                    regular: 'fonts/Geist-ExtraBold.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-ExtraBold.ttf'
                },
                'geist-black': {
                    regular: 'fonts/Geist-Black.ttf',
                    light: 'fonts/Geist-Light.ttf',
                    medium: 'fonts/Geist-Medium.ttf',
                    semibold: 'fonts/Geist-SemiBold.ttf',
                    bold: 'fonts/Geist-Bold.ttf',
                    extrabold: 'fonts/Geist-ExtraBold.ttf',
                    black: 'fonts/Geist-Black.ttf',
                    thin: 'fonts/Geist-Thin.ttf',
                    extralight: 'fonts/Geist-ExtraLight.ttf',
                    italic: 'fonts/Geist-Black.ttf'
                },

                // Lato (Complete Set)
                'lato': {
                    regular: 'fonts/Lato-Regular.ttf',
                    light: 'fonts/Lato-Light.ttf',
                    medium: 'fonts/Lato-Regular.ttf', // Fallback
                    semibold: 'fonts/Lato-Bold.ttf', // Fallback
                    bold: 'fonts/Lato-Bold.ttf',
                    extrabold: 'fonts/Lato-Black.ttf', // Fallback
                    black: 'fonts/Lato-Black.ttf',
                    thin: 'fonts/Lato-Light.ttf', // Fallback
                    extralight: 'fonts/Lato-Light.ttf', // Fallback
                    italic: 'fonts/Lato-Italic.ttf'
                },
                'lato-light': {
                    regular: 'fonts/Lato-Light.ttf',
                    light: 'fonts/Lato-Light.ttf',
                    medium: 'fonts/Lato-Regular.ttf',
                    semibold: 'fonts/Lato-Bold.ttf',
                    bold: 'fonts/Lato-Bold.ttf',
                    extrabold: 'fonts/Lato-Black.ttf',
                    black: 'fonts/Lato-Black.ttf',
                    thin: 'fonts/Lato-Light.ttf',
                    extralight: 'fonts/Lato-Light.ttf',
                    italic: 'fonts/Lato-Italic.ttf'
                },
                'lato-regular': {
                    regular: 'fonts/Lato-Regular.ttf',
                    light: 'fonts/Lato-Light.ttf',
                    medium: 'fonts/Lato-Regular.ttf',
                    semibold: 'fonts/Lato-Bold.ttf',
                    bold: 'fonts/Lato-Bold.ttf',
                    extrabold: 'fonts/Lato-Black.ttf',
                    black: 'fonts/Lato-Black.ttf',
                    thin: 'fonts/Lato-Light.ttf',
                    extralight: 'fonts/Lato-Light.ttf',
                    italic: 'fonts/Lato-Italic.ttf'
                },
                'lato-bold': {
                    regular: 'fonts/Lato-Bold.ttf',
                    light: 'fonts/Lato-Light.ttf',
                    medium: 'fonts/Lato-Regular.ttf',
                    semibold: 'fonts/Lato-Bold.ttf',
                    bold: 'fonts/Lato-Bold.ttf',
                    extrabold: 'fonts/Lato-Black.ttf',
                    black: 'fonts/Lato-Black.ttf',
                    thin: 'fonts/Lato-Light.ttf',
                    extralight: 'fonts/Lato-Light.ttf',
                    italic: 'fonts/Lato-Italic.ttf'
                },
                'lato-black': {
                    regular: 'fonts/Lato-Black.ttf',
                    light: 'fonts/Lato-Light.ttf',
                    medium: 'fonts/Lato-Regular.ttf',
                    semibold: 'fonts/Lato-Bold.ttf',
                    bold: 'fonts/Lato-Bold.ttf',
                    extrabold: 'fonts/Lato-Black.ttf',
                    black: 'fonts/Lato-Black.ttf',
                    thin: 'fonts/Lato-Light.ttf',
                    extralight: 'fonts/Lato-Light.ttf',
                    italic: 'fonts/Lato-Italic.ttf'
                },
                
                // Poppins
                'poppins': {
                    regular: 'fonts/poppins-latin-400-normal.ttf',
                    light: 'fonts/poppins-latin-400-normal.ttf', // Fallback
                    medium: 'fonts/poppins-latin-500-normal.ttf',
                    semibold: 'fonts/poppins-latin-500-normal.ttf', // Fallback
                    bold: 'fonts/poppins-latin-500-normal.ttf', // Fallback
                    extrabold: 'fonts/poppins-latin-500-normal.ttf', // Fallback
                    black: 'fonts/poppins-latin-500-normal.ttf', // Fallback
                    thin: 'fonts/poppins-latin-400-normal.ttf', // Fallback
                    extralight: 'fonts/poppins-latin-400-normal.ttf', // Fallback
                    italic: 'fonts/poppins-latin-400-normal.ttf'
                },

                // Variable Fonts
                'montserrat': {
                    regular: 'fonts/Montserrat-VariableFont_wght.ttf',
                    light: 'fonts/Montserrat-VariableFont_wght.ttf',
                    medium: 'fonts/Montserrat-VariableFont_wght.ttf',
                    semibold: 'fonts/Montserrat-VariableFont_wght.ttf',
                    bold: 'fonts/Montserrat-VariableFont_wght.ttf',
                    extrabold: 'fonts/Montserrat-VariableFont_wght.ttf',
                    black: 'fonts/Montserrat-VariableFont_wght.ttf',
                    thin: 'fonts/Montserrat-VariableFont_wght.ttf',
                    extralight: 'fonts/Montserrat-VariableFont_wght.ttf',
                    italic: 'fonts/Montserrat-VariableFont_wght.ttf'
                },
                'oswald': {
                    regular: 'fonts/Oswald-VariableFont_wght.ttf',
                    light: 'fonts/Oswald-VariableFont_wght.ttf',
                    medium: 'fonts/Oswald-VariableFont_wght.ttf',
                    semibold: 'fonts/Oswald-VariableFont_wght.ttf',
                    bold: 'fonts/Oswald-VariableFont_wght.ttf',
                    extrabold: 'fonts/Oswald-VariableFont_wght.ttf',
                    black: 'fonts/Oswald-VariableFont_wght.ttf',
                    thin: 'fonts/Oswald-VariableFont_wght.ttf',
                    extralight: 'fonts/Oswald-VariableFont_wght.ttf',
                    italic: 'fonts/Oswald-VariableFont_wght.ttf'
                },

                // Specialty Fonts
                'rye': {
                    regular: 'fonts/Rye-Regular.ttf',
                    light: 'fonts/Rye-Regular.ttf',
                    medium: 'fonts/Rye-Regular.ttf',
                    semibold: 'fonts/Rye-Regular.ttf',
                    bold: 'fonts/Rye-Regular.ttf',
                    extrabold: 'fonts/Rye-Regular.ttf',
                    black: 'fonts/Rye-Regular.ttf',
                    thin: 'fonts/Rye-Regular.ttf',
                    extralight: 'fonts/Rye-Regular.ttf',
                    italic: 'fonts/Rye-Regular.ttf'
                },
                'alumni': {
                    regular: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    light: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    medium: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    semibold: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    bold: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    extrabold: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    black: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    thin: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    extralight: 'fonts/AlumniSansCollegiateOne-Regular.ttf',
                    italic: 'fonts/AlumniSansCollegiateOne-Regular.ttf'
                }
            },
            
            // --- Initialization ---
            init: function() {
                this.cacheDOMElements();
                this.loadSettings();
                this.updateColorSwatches();
                this.bindEvents();
                this.updateUIState();
                lucide.createIcons();
                this.initPdfLibSettings();
            },
            
            initPdfLibSettings: function() {
                // Settings that are no longer manually controlled
                $('#style-preset, #modal-style-preset').prop('disabled', true).attr('title', 'Styling is handled by pdf-lib logic');
                
                // Enable the font dropdowns
                $('#font-family, #modal-font-family').prop('disabled', false).attr('title', 'Select a font family');
            },

            cacheDOMElements: function() {
                this.dom = {
                    dropZone: $('#drop-zone'),
                    fileInput: $('#file-input'),
                    browseFiles: $('#browse-files'),
                    fileList: $('#file-list'),
                    fileListHeader: $('#file-list-header'),
                    emptyQueueMessage: $('#empty-queue-message'),
                    clearQueue: $('#clear-queue'),
                    settingInputs: $('.setting-input'),
                    generateBatch: $('#generate-batch'),
                    batchButtonText: $('#batch-button-text'),
                    progressArea: $('#progress-area'),
                    progressText: $('#progress-text'),
                    progressBar: $('#progress-bar'),
                    globalStatus: $('#global-status'),
                    errorMessage: $('#error-message'),
                    errorText: $('#error-text'),
                    pdfRenderArea: $('#pdf-render-area'), // No longer used for generation
                    pdfContent: $('#pdf-content'), // No longer used for generation
                    modal: $('#settings-modal'),
                    modalContent: $('.modal-content'),
                    closeModal: $('#close-modal'),
                    cancelModal: $('#cancel-modal'),
                    saveOverrides: $('#save-overrides'),
                    clearOverrides: $('#clear-overrides'),
                    modalFileName: $('#modal-file-name'),
                    importSettingsBtn: $('#import-settings-btn'),
                    exportSettingsBtn: $('#export-settings-btn'),
                    importSettingsInput: $('#import-settings-input'),
                    mobileMenuButton: $('#mobile-menu-button'),
                    mobileMenu: $('#mobile-menu'),
                    toastContainer: $('#toast-container'),
                    toastIcon: $('#toast-icon'),
                    toastTitle: $('#toast-title'),
                    toastMessage: $('#toast-message'),
                    toastExample: $('#toast-example'),
                };
            },

            // --- Event Binding ---
            bindEvents: function() {
                // Settings persistence
                this.dom.settingInputs.on('change keyup', this.saveSettings.bind(this));

                // Live update color swatches (ensure visible even if native input is white)
                const colorSelectors = '#theme-color-main, #theme-color-secondary, #theme-color-text, #theme-color-bg';
                $(document).on('input change', colorSelectors, () => this.updateColorSwatches());

                // Drag and Drop
                this.dom.dropZone.on('dragover', (e) => this.handleDragOver(e));
                this.dom.dropZone.on('dragleave', (e) => this.handleDragLeave(e));
                this.dom.dropZone.on('drop', (e) => this.handleDrop(e));

                // File Browsing
                this.dom.browseFiles.on('click', () => this.dom.fileInput.click());
                this.dom.fileInput.on('change', (e) => this.handleFileSelect(e));

                // Import/Export
                this.dom.exportSettingsBtn.on('click', this.exportSettings.bind(this));
                this.dom.importSettingsBtn.on('click', () => this.dom.importSettingsInput.click());
                this.dom.importSettingsInput.on('change', this.importSettings.bind(this));

                // Queue Management
                this.dom.fileList.on('click', '.remove-file-btn', (e) => this.removeFile(e));
                this.dom.clearQueue.on('click', this.clearQueue.bind(this));

                // Batch Processing
                this.dom.generateBatch.on('click', this.processBatch.bind(this));

                // Course Type preset switching (apply safe visual defaults only)
                $('#course-type').on('change', () => {
                    const type = $('#course-type').val();
                    this.applyCourseTypePreset(type);
                    this.updateColorSwatches();
                    this.saveSettings();
                });

                // Modal Events
                this.dom.fileList.on('click', '.edit-file-btn', (e) => this.openSettingsModal(e));
                this.dom.closeModal.on('click', this.closeSettingsModal.bind(this));
                this.dom.cancelModal.on('click', this.closeSettingsModal.bind(this));
                this.dom.modal.on('click', (e) => {
                    if (e.target === this.dom.modal[0]) this.closeSettingsModal();
                });
                this.dom.saveOverrides.on('click', this.saveFileOverrides.bind(this));
                this.dom.clearOverrides.on('click', this.clearFileOverrides.bind(this));

                // Mobile Menu
                this.dom.mobileMenuButton.on('click', this.toggleMobileMenu.bind(this));
            },

            // Define safe presets for course types. These only adjust theme colors, font, and header weight.
            getCourseTypePreset: function(type) {
                const presets = {
                    wealth: {
                        themeColor: '#268ca7',
                        themeColorSecondary: '#1e6a80',
                        themeColorText: '#333333',
                        themeColorBg: '#f7f8fa',
                        fontFamily: 'geist',
                        headerFontWeight: 'semibold',
                        textAlignment: 'left',
                        paragraphSpacing: 'normal',
                        includePageNumbers: true,
                        headingStylePreset: 'clean'
                    },
                    education: {
                        themeColor: '#2563eb',
                        themeColorSecondary: '#1e40af',
                        themeColorText: '#1f2937',
                        themeColorBg: '#f8fafc',
                        fontFamily: 'lato',
                        headerFontWeight: 'bold',
                        textAlignment: 'justify',
                        paragraphSpacing: 'normal',
                        includePageNumbers: true,
                        headingStylePreset: 'clean'
                    },
                    lecture: {
                        themeColor: '#111827',
                        themeColorSecondary: '#4b5563',
                        themeColorText: '#111827',
                        themeColorBg: '#ffffff',
                        fontFamily: 'oswald',
                        headerFontWeight: 'black',
                        textAlignment: 'left',
                        paragraphSpacing: 'compact',
                        includePageNumbers: true,
                        headingStylePreset: 'bold'
                    },
                    general: {
                        themeColor: '#10b981',
                        themeColorSecondary: '#047857',
                        themeColorText: '#374151',
                        themeColorBg: '#f9fafb',
                        fontFamily: 'montserrat',
                        headerFontWeight: 'medium',
                        textAlignment: 'justify',
                        paragraphSpacing: 'relaxed',
                        includePageNumbers: true,
                        headingStylePreset: 'minimalist'
                    }
                };
                return presets[type] || presets['wealth'];
            },

            // Apply preset to UI inputs without touching titles/footers/filenames to avoid surprises
            applyCourseTypePreset: function(type) {
                const p = this.getCourseTypePreset(type);
                if (!p) return;
                $('#theme-color-main').val(p.themeColor);
                $('#theme-color-secondary').val(p.themeColorSecondary);
                $('#theme-color-text').val(p.themeColorText);
                $('#theme-color-bg').val(p.themeColorBg);
                $('#font-family').val(p.fontFamily);
                $('#header-font-weight').val(p.headerFontWeight);
                if (p.textAlignment) $('#text-alignment').val(p.textAlignment);
                if (p.paragraphSpacing) $('#paragraph-spacing').val(p.paragraphSpacing);
                if (typeof p.includePageNumbers === 'boolean') $('#include-page-numbers').prop('checked', p.includePageNumbers);
                if (p.headingStylePreset) $('#heading-style-preset').val(p.headingStylePreset);
            },

            toggleMobileMenu: function() {
                this.dom.mobileMenu.toggleClass('hidden');
                // Toggle icon
                const icon = this.dom.mobileMenuButton.find('i');
                if (this.dom.mobileMenu.hasClass('hidden')) {
                    icon.attr('data-lucide', 'menu');
                } else {
                    icon.attr('data-lucide', 'x');
                }
                lucide.createIcons();
            },

            // --- Settings Management ---
            getGlobalSettings: function() {
                return {
                    courseTitle: $('#course-title').val(),
                    instructorName: $('#instructor-name').val(),
                    logoUrl: $('#logo-url').val(),
                    footerText: $('#footer-text').val(),
                    includeToc: $('#include-toc').is(':checked'), // NEW
                    themeColor: $('#theme-color-main').val(), // Main color
                    themeColorSecondary: $('#theme-color-secondary').val(), // Secondary color
                    themeColorText: $('#theme-color-text').val(), // Text color
                    themeColorBg: $('#theme-color-bg').val(), // Background color
                    themeType: $('#theme-type').val(), // Theme type selector
                    courseType: $('#course-type').val(),
                    textAlignment: $('#text-alignment').val(),
                    paragraphSpacing: $('#paragraph-spacing').val(),
                    includePageNumbers: $('#include-page-numbers').is(':checked'),
                    headingStylePreset: $('#heading-style-preset').val(),
                    fontFamily: $('#font-family').val(), // NEW: This is now the key, e.g., 'lato'
                    fontSize: $('#font-size').val(),
                    headerFontWeight: $('#header-font-weight').val(), // NEW: Header font weight
                    zipFilename: $('#zip-filename').val() || 'batch-export',
                    stylePreset: $('#style-preset').val(), // No longer used
                };
            },

            saveSettings: function() {
                const settings = this.getGlobalSettings();
                localStorage.setItem(this.SETTINGS_KEY, JSON.stringify(settings));
            },

            applySettingsToDOM: function(settings) {
                if (!settings) return;
                
                $('#course-title').val(settings.courseTitle || 'My Awesome Wealth Course');
                $('#instructor-name').val(settings.instructorName || 'Dr. Jane Doe');
                $('#logo-url').val(settings.logoUrl || '');
                $('#footer-text').val(settings.footerText || 'Â© 2025 Wealth Builders Inc.');
                $('#include-toc').prop('checked', settings.includeToc || false); // NEW

                // Apply 4-circle color system
                $('#theme-color-main').val(settings.themeColor || '#268ca7');
                $('#theme-color-secondary').val(settings.themeColorSecondary || '#1e6a80');
                $('#theme-color-text').val(settings.themeColorText || '#333333');
                $('#theme-color-bg').val(settings.themeColorBg || '#f7f8fa');
                $('#theme-type').val(settings.themeType || 'wealth-course'); // Theme type selector
                $('#course-type').val(settings.courseType || 'wealth');
                $('#text-alignment').val(settings.textAlignment || 'left');
                $('#paragraph-spacing').val(settings.paragraphSpacing || 'normal');
                $('#include-page-numbers').prop('checked', settings.includePageNumbers !== false);
                $('#heading-style-preset').val(settings.headingStylePreset || 'clean');

                $('#font-family').val(settings.fontFamily || 'geist'); // NEW
                $('#font-size').val(settings.fontSize || 'medium');
                $('#header-font-weight').val(settings.headerFontWeight || 'semibold'); // NEW
                $('#zip-filename').val(settings.zipFilename || 'wealth-course-batch');
                this.updateColorSwatches();
            },

            // --- UI Helpers ---
            updateColorSwatches: function() {
                try {
                    const ids = ['#theme-color-main', '#theme-color-secondary', '#theme-color-text', '#theme-color-bg'];
                    ids.forEach((sel) => {
                        const el = document.querySelector(sel);
                        if (!el) return;
                        const val = el.value || '#ffffff';
                        // Update visible swatch
                        const wrap = el.closest('.color-circle');
                        if (wrap) {
                            const visual = wrap.querySelector('.color-visual');
                            if (visual) {
                                visual.style.backgroundColor = val;
                            }
                        }
                    });
                } catch (e) {
                    // no-op
                }
            },

            loadSettings: function() {
                const settings = JSON.parse(localStorage.getItem(this.SETTINGS_KEY));
                if (settings) {
                    this.applySettingsToDOM(settings);
                }
            },

            // --- Import/Export Functions ---
            exportSettings: function() {
                try {
                    const settings = this.getGlobalSettings();
                    const jsonString = JSON.stringify(settings, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    saveAs(blob, 'mdman-settings.json');
                } catch (err) {
                    console.error("Error exporting settings:", err);
                    this.showGlobalError("Failed to export settings. See console for details.");
                }
            },

            importSettings: function(e) {
                const file = e.target.files[0];
                if (!file || file.type !== 'application/json') {
                    if (file) {
                        this.showGlobalError("Import failed: File must be a valid .json file.");
                    }
                    $(e.target).val(null); // Reset input
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const content = event.target.result;
                        const settings = JSON.parse(content);
                        
                        // Basic validation (check for at least one known key)
                        if (!settings.courseTitle && !settings.zipFilename) {
                            throw new Error("File does not appear to be a valid settings file.");
                        }

                        this.applySettingsToDOM(settings);
                        this.saveSettings(); // Save imported settings to localStorage
                        
                        this.dom.errorMessage.addClass('hidden');
                        
                    } catch (err) {
                        console.error("Error importing settings:", err);
                        this.showGlobalError(`Import failed: ${err.message}`);
                    }
                };
                reader.onerror = () => {
                    console.error("Failed to read imported file.");
                    this.showGlobalError("Failed to read the selected file.");
                };
                
                reader.readAsText(file);
                $(e.target).val(null); // Reset input after read
            },


            // --- File & Queue Management ---
            handleDragOver: function(e) {
                e.preventDefault(); e.stopPropagation();
                this.dom.dropZone.addClass('drag-over');
            },

            handleDragLeave: function(e) {
                e.preventDefault(); e.stopPropagation();
                this.dom.dropZone.removeClass('drag-over');
            },

            handleDrop: function(e) {
                e.preventDefault(); e.stopPropagation();
                this.dom.dropZone.removeClass('drag-over');
                const files = e.originalEvent.dataTransfer.files;
                if (files.length) {
                    Array.from(files).forEach(file => this.addFileToQueue(file));
                }
            },

            handleFileSelect: function(e) {
                if (e.target.files.length) {
                    Array.from(e.target.files).forEach(file => this.addFileToQueue(file));
                }
                $(e.target).val(null); // Reset input
            },

            addFileToQueue: function(file) {
                if (!file.type.match('markdown') && !file.name.endsWith('.md')) {
                    console.warn(`File "${file.name}" is not a Markdown file.`);
                    return; 
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const fileId = 'file-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    const fileData = {
                        id: fileId,
                        name: file.name,
                        size: file.size,
                        content: e.target.result,
                        overrideSettings: null 
                    };
                    this.fileQueue.push(fileData);
                    
                    this.fileQueue.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                    
                    this.dom.fileList.children(':not(#empty-queue-message)').remove();
                    
                    this.fileQueue.forEach(f => {
                        const hasOverrides = f.overrideSettings ? 'text-[#268ca7]' : 'text-gray-400';
                        const fileHtml = `
                            <div id="${f.id}" class="flex items-center justify-between p-3 bg-gray-50 rounded-3xl border border-gray-200 transition-all">
                                <div class="flex items-center overflow-hidden mr-2">
                                    <i data-lucide="file-text" class="w-5 h-5 mr-3 text-[#268ca7] flex-shrink-0"></i>
                                    <span class="text-sm text-gray-800 truncate" title="${f.name}">${f.name}</span>
                                    <span class="text-xs text-gray-500 ml-2 flex-shrink-0">(${this.formatBytes(f.size)})</span>
                                </div>
                                <div class="flex items-center space-x-2 flex-shrink-0">
                                    <div id="${f.id}-status" class="text-sm text-gray-500">Uploaded</div>
                                    <button class="edit-file-btn ${hasOverrides} hover:text-[#268ca7]" data-file-id="${f.id}" title="File-specific settings">
                                        <i data-lucide="settings-2" class="w-5 h-5"></i>
                                    </button>
                                    <button class="remove-file-btn text-red-400 hover:text-red-600" data-file-id="${f.id}" title="Remove file">
                                        <i data-lucide="x" class="w-5 h-5"></i>
                                    </button>
                                </div>
                            </div>
                        `;
                        this.dom.fileList.append(fileHtml);
                    });
                    
                    lucide.createIcons(); // Re-render icons
                    this.updateUIState();
                    this.checkFileQueueFormat(); // Check filename format and show/hide toast
                };
                reader.onerror = () => {
                    console.error(`Failed to read file "${file.name}".`);
                };
                reader.readAsText(file);
            },

            removeFile: function(e) {
                const fileId = $(e.currentTarget).data('file-id');
                this.fileQueue = this.fileQueue.filter(f => f.id !== fileId);
                $(`#${fileId}`).remove();
                this.updateUIState();
                this.checkFileQueueFormat(); // Check filename format and show/hide toast
            },

            clearQueue: function() {
                this.fileQueue = [];
                this.dom.fileList.children(':not(#empty-queue-message)').remove();
                this.updateUIState();
                this.checkFileQueueFormat(); // Check filename format and show/hide toast
            },

            // --- UI State & Helpers ---
            updateUIState: function() {
                if (this.fileQueue.length > 0) {
                    this.dom.fileListHeader.removeClass('hidden');
                    this.dom.emptyQueueMessage.addClass('hidden');
                    this.dom.generateBatch.prop('disabled', false);
                    this.dom.batchButtonText.text(`Start Batch Process (${this.fileQueue.length} files)`);
                } else {
                    this.dom.fileListHeader.addClass('hidden');
                    this.dom.emptyQueueMessage.removeClass('hidden');
                    this.dom.generateBatch.prop('disabled', true);
                    this.dom.batchButtonText.text('Start Batch Process');
                    this.dom.progressArea.addClass('hidden');
                }
            },

            formatBytes: function(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            },

            updateFileStatus: function(fileId, status, message = '') {
                const $statusEl = $(`#${fileId}-status`);
                switch (status) {
                    case 'processing':
                        $statusEl.html('<div class="spinner"></div>').removeClass().addClass('text-sm');
                        break;
                    case 'done':
                        $statusEl.html('<i data-lucide="check-circle" class="w-5 h-5 text-green-500"></i>').removeClass().addClass('text-sm');
                        break;
                    case 'error':
                        $statusEl.html(`<i data-lucide="alert-triangle" class="w-5 h-5 text-red-500" title="${message}"></i>`).removeClass().addClass('text-sm');
                        break;
                    case 'waiting':
                    default:
                        $statusEl.text('Uploaded').removeClass().addClass('text-sm text-gray-500');
                }
                lucide.createIcons();
            },

            // --- Toast System ---
            showToast: function(type, title, message, example = '') {
                // Set icon based on type
                const iconMap = {
                    'suggestion': 'lightbulb',
                    'info': 'info',
                    'warning': 'alert-triangle',
                    'success': 'check-circle',
                    'error': 'x-circle'
                };
                
                this.dom.toastIcon.attr('data-lucide', iconMap[type] || 'info');
                this.dom.toastTitle.text(title);
                this.dom.toastMessage.text(message);
                
                if (example) {
                    this.dom.toastExample.text(example).removeClass('hidden');
                } else {
                    this.dom.toastExample.addClass('hidden');
                }
                
                this.dom.toastContainer.removeClass('hidden');
                lucide.createIcons();
            },

            hideToast: function() {
                this.dom.toastContainer.addClass('hidden');
            },

            checkFilenameFormat: function(filename) {
                // Check if filename follows numbered prefix format (e.g., "01 - filename.md", "02 - filename.md")
                const numberedPrefixPattern = /^\d+\s*-\s*.+\.md$/i;
                return numberedPrefixPattern.test(filename);
            },

            checkFileQueueFormat: function() {
                if (this.fileQueue.length === 0) {
                    this.hideToast();
                    return;
                }
                
                const hasNonNumberedFiles = this.fileQueue.some(file => !this.checkFilenameFormat(file.name));
                
                if (hasNonNumberedFiles) {
                    this.showToast(
                        'suggestion',
                        'Suggestion:',
                        'Use numbered prefixes in your filenames for automatic ordering:',
                        '01 - Introduction.md, 02 - Getting Started.md, 03 - Advanced Topics.md'
                    );
                } else {
                    this.hideToast();
                }
            },

            showGlobalError: function(message) {
                this.dom.errorText.text(message);
                this.dom.errorMessage.removeClass('hidden');
                this.dom.progressArea.addClass('hidden');
                this.dom.generateBatch.prop('disabled', false).removeClass('opacity-50');
                this.dom.batchButtonText.text(`Start Batch Process (${this.fileQueue.length} files)`);
            },

            // --- Per-File Settings Modal ---
            openSettingsModal: function(e) {
                const fileId = $(e.currentTarget).data('file-id');
                const file = this.fileQueue.find(f => f.id === fileId);
                if (!file) return;

                this.dom.modal.data('file-id', fileId);
                this.dom.modalFileName.text(file.name);

                const globalSettings = this.getGlobalSettings();
                const settings = file.overrideSettings || globalSettings;

                $('#modal-course-title').val(settings.courseTitle);
                $('#modal-instructor-name').val(settings.instructorName);
                $('#modal-logo-url').val(settings.logoUrl);
                $('#modal-footer-text').val(settings.footerText);
                $('#modal-include-toc').prop('checked', settings.includeToc); // NEW

                // Apply 4-circle color system to modal
                $('#modal-theme-color-main').val(settings.themeColor || '#268ca7');
                $('#modal-theme-color-secondary').val(settings.themeColorSecondary || '#1e6a80');
                $('#modal-theme-color-text').val(settings.themeColorText || '#333333');
                $('#modal-theme-color-bg').val(settings.themeColorBg || '#f7f8fa');
                $('#modal-theme-type').val(settings.themeType || 'wealth-course'); // Theme type selector

                $('#modal-font-family').val(settings.fontFamily); // NEW
                $('#modal-font-size').val(settings.fontSize);
                $('#modal-header-font-weight').val(settings.headerFontWeight || 'semibold'); // NEW
            },

            closeSettingsModal: function() {
                this.dom.modal.addClass('invisible opacity-0');
                this.dom.modalContent.addClass('opacity-0 -translate-y-10');
                this.dom.modal.data('file-id', null);
            },

            saveFileOverrides: function() {
                const fileId = this.dom.modal.data('file-id');
                const file = this.fileQueue.find(f => f.id === fileId);
                if (!file) return;

                file.overrideSettings = {
                    courseTitle: $('#modal-course-title').val(),
                    instructorName: $('#modal-instructor-name').val(),
                    logoUrl: $('#modal-logo-url').val(),
                    footerText: $('#modal-footer-text').val(),
                    includeToc: $('#modal-include-toc').is(':checked'), // NEW

                    // Apply 4-circle color system to overrides
                    themeColor: $('#modal-theme-color-main').val(),
                    themeColorSecondary: $('#modal-theme-color-secondary').val(),
                    themeColorText: $('#modal-theme-color-text').val(),
                    themeColorBg: $('#modal-theme-color-bg').val(),
                    themeType: $('#modal-theme-type').val(), // Theme type selector

                    fontFamily: $('#modal-font-family').val(), // NEW
                    fontSize: $('#modal-font-size').val(),
                    headerFontWeight: $('#modal-header-font-weight').val(), // NEW
                    stylePreset: $('#modal-style-preset').val(), // No longer used
                };

                $(`#${fileId}`).find('.edit-file-btn').removeClass('text-gray-400').addClass('text-[#268ca7]');
                
                this.closeSettingsModal();
            },

            clearFileOverrides: function() {
                const fileId = this.dom.modal.data('file-id');
                const file = this.fileQueue.find(f => f.id === fileId);
                if (!file) return;

                file.overrideSettings = null;

                $(`#${fileId}`).find('.edit-file-btn').removeClass('text-[#268ca7]').addClass('text-gray-400');

                this.closeSettingsModal();
            },


            // =================================================================
            // --- NEW: PDF-LIB CORE LOGIC (Replaces html2pdf.js) ---
            // =================================================================

            // --- NEW: Helper functions from generator.js ---

            drawText: function(text, options) {
                const { page, font, size, color, y, lineHeight, maxWidth, align = 'center' } = options;
                const { width: pageWidth, height: pageHeight } = page.getSize();

                // === COMPREHENSIVE INPUT VALIDATION ===
                if (!page || !font || !size || y === undefined) {
                    console.warn('drawText: Missing required parameters');
                    return y;
                }

                // === TEXT PROCESSING OPTIMIZATION ===
                let processedText = String(text || '');

                // Handle special cases
                if (processedText.trim() === '') {
                    return y - (lineHeight || size * 1.4);
                }

                // Remove problematic characters that might cause rendering issues
                processedText = processedText.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');

                // === ADVANCED WIDTH CALCULATION ===
                const leftMargin = 72;
                const rightMargin = 72;
                const usableWidth = pageWidth - leftMargin - rightMargin;
                const effectiveMaxWidth = Math.min(maxWidth || usableWidth, usableWidth);

                // Ensure minimum width for readability
                const minTextWidth = Math.max(effectiveMaxWidth, 100);

                // === SMART TEXT WRAPPING ===
                const lines = this.wrapText(processedText, font, size, minTextWidth);

                if (!lines || lines.length === 0) {
                    return y;
                }

                // === DYNAMIC LINE HEIGHT CALCULATION ===
                let effectiveLineHeight;
                if (lineHeight && typeof lineHeight === 'number' && lineHeight > 0) {
                    effectiveLineHeight = lineHeight;
                } else if (size && typeof size === 'number' && size > 0) {
                    effectiveLineHeight = size * 1.4;
                } else {
                    effectiveLineHeight = 12; // fallback
                }

                // === ADVANCED POSITIONING LOGIC ===
                let currentY = y;
                const bottomMargin = 72;
                const footerSpace = 50;

                // Early exit if there's clearly no vertical space (e.g., footer area)
                if ((currentY - bottomMargin - footerSpace) < effectiveLineHeight) {
                    return currentY;
                }

                lines.forEach((line, lineIndex) => {
                    if (!line || line.trim() === '') {
                        currentY -= effectiveLineHeight * 0.5;
                        return;
                    }

                    const textWidth = font.widthOfTextAtSize(line, size);
                    let x;

                    // === SOPHISTICATED ALIGNMENT LOGIC ===
                    if (align === 'center') {
                        x = (pageWidth - textWidth) / 2;
                        // Ensure centered text doesn't exceed boundaries
                        if (x < leftMargin) x = leftMargin;
                        if (x + textWidth > pageWidth - rightMargin) {
                            x = leftMargin + (usableWidth - textWidth) / 2;
                        }
                    } else if (align === 'right') {
                        x = pageWidth - rightMargin - textWidth;
                        // Ensure right-aligned text doesn't exceed left margin
                        if (x < leftMargin) x = leftMargin;
                    } else if (align === 'justify') {
                        x = leftMargin;
                        // Note: Full justification would require character-level positioning
                    } else {
                        // left align (default)
                        x = Math.max(options.margin || leftMargin, leftMargin);
                    }

                    // === BOUNDARY VALIDATION AND CORRECTION ===
                    const maxX = pageWidth - rightMargin - textWidth;
                    const actualX = Math.max(leftMargin, Math.min(x, maxX));

                    // === SPACE VALIDATION ===
                    const requiredSpace = effectiveLineHeight;
                    const availableSpace = currentY - bottomMargin - footerSpace;

                    if (availableSpace < requiredSpace) {
                        console.warn('Text would exceed page boundary');
                        return currentY;
                    }

                    // === OPTIMIZED TEXT RENDERING ===
                    try {
                        if (align === 'justify' && lineIndex < lines.length - 1) {
                            const words = line.split(' ');
                            if (words.length > 1) {
                                const baseWidth = font.widthOfTextAtSize(line, size);
                                const spaceCount = words.length - 1;
                                const extra = Math.max(0, usableWidth - baseWidth);
                                const extraPerSpace = extra / spaceCount;
                                const baseSpace = font.widthOfTextAtSize(' ', size);
                                let cursorX = leftMargin;
                                for (let w = 0; w < words.length; w++) {
                                    const word = words[w];
                                    if (word) {
                                        page.drawText(word, { x: cursorX, y: currentY, font, size, color: color || undefined });
                                        cursorX += font.widthOfTextAtSize(word, size);
                                    }
                                    if (w < words.length - 1) {
                                        cursorX += baseSpace + extraPerSpace;
                                    }
                                }
                            } else {
                                page.drawText(line, { x: actualX, y: currentY, font, size, color: color || undefined, lineHeight: effectiveLineHeight });
                            }
                        } else {
                            page.drawText(line, {
                                x: actualX,
                                y: currentY,
                                font: font,
                                size: size,
                                color: color || undefined,
                                lineHeight: effectiveLineHeight
                            });
                        }
                    } catch (renderError) {
                        console.error('Text rendering error:', renderError);
                        // Try fallback rendering
                        try {
                            page.drawText(line.replace(/[^\x20-\x7E]/g, '?'), {
                                x: actualX,
                                y: currentY,
                                font: font,
                                size: size,
                                // default color omitted
                                lineHeight: effectiveLineHeight
                            });
                        } catch (fallbackError) {
                            console.error('Fallback rendering failed:', fallbackError);
                        }
                    }

                    currentY -= effectiveLineHeight;
                });

                return currentY;
            },

            // NEW: Draw text with inline formatting (bold, italic, etc.)
            drawStyledText: function(text, options) {
                const { page, font, boldFont, italicFont, size, color, y, lineHeight, maxWidth, align = 'left' } = options;
                const { width: pageWidth } = page.getSize();

                // Ensure we have valid maxWidth and constrain to page boundaries
                const effectiveMaxWidth = Math.min(maxWidth || pageWidth - 144, pageWidth - 144); // 144 = 72px margin on each side

                // === ADVANCED MARKDOWN PARSING ===
                const parseInlineMarkdown = (text) => {
                    if (!text || typeof text !== 'string') return '';

                    let parsed = text;

                    // Handle bold text with proper escaping
                    if (parsed.includes('**')) {
                        parsed = parsed.replace(/\*\*(.+?)\*\*/g, '<b>$1</b>');
                    }

                    // Handle italic text (avoid double processing)
                    if (parsed.includes('*')) {
                        parsed = parsed.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<i>$1</i>');
                    }

                    // Handle inline code
                    if (parsed.includes('`')) {
                        parsed = parsed.replace(/`(.+?)`/g, '<code>$1</code>');
                    }

                    // Clean up malformed tags
                    parsed = parsed.replace(/<[^>]*>/g, '');

                    return parsed;
                };
                
                const styledText = parseInlineMarkdown(text);
                const lines = this.wrapText(styledText, font, size, effectiveMaxWidth);

                const effectiveLineHeight = lineHeight || size * 1.4;
                let currentY = y;
                
                lines.forEach(line => {
                    // Split line into styled segments
                    const segments = this.parseStyledSegments(line, font, boldFont, italicFont, size, color);

                    let x = options.margin || 72; // Default to left margin
                    if (align === 'center') {
                        const totalWidth = segments.reduce((sum, seg) => sum + seg.width, 0);
                        x = (pageWidth - totalWidth) / 2;
                    } else if (align === 'right') {
                        const totalWidth = segments.reduce((sum, seg) => sum + seg.width, 0);
                        x = Math.min(pageWidth - 72 - totalWidth, pageWidth - 72 - effectiveMaxWidth);
                    } else {
                        // left align - ensure we don't exceed left margin
                        x = Math.max(options.margin || 72, 72);
                    }

                    // Ensure we don't exceed page boundaries
                    let currentX = Math.max(72, Math.min(x, pageWidth - 72));

                    segments.forEach(segment => {
                        // Check if segment would exceed right boundary
                        if (currentX + segment.width > pageWidth - 72) {
                            // Move to next line if segment doesn't fit
                            currentY -= effectiveLineHeight;
                            currentX = 72;
                        }

                        page.drawText(segment.text, {
                            x: currentX, y: currentY, font: segment.font, size: segment.size, color: segment.color
                        });
                        currentX += segment.width;
                    });
                    
                    currentY -= effectiveLineHeight;
                });
                return currentY;
            },

            // === ENHANCED: Parse text into styled segments ===
            parseStyledSegments: function(text, regularFont, boldFont, italicFont, size, color) {
                // === COMPREHENSIVE INPUT VALIDATION ===
                if (!text || typeof text !== 'string') {
                    return [{
                        text: String(text || ''),
                        font: regularFont,
                        size: size,
                        color: color,
                        width: regularFont ? regularFont.widthOfTextAtSize(String(text || ''), size) : 100
                    }];
                }

                if (!regularFont) {
                    console.warn('parseStyledSegments: Missing regular font');
                    regularFont = { widthOfTextAtSize: () => 100 };
                }

                const segments = [];

                // === OPTIMIZED EARLY RETURN ===
                const hasBold = text.includes('<b>');
                const hasItalic = text.includes('<i>');
                const hasCode = text.includes('<code>');

                if (!hasBold && !hasItalic && !hasCode) {
                    // No styling needed, return single segment
                    const cleanText = text.replace(/<[^>]*>/g, '');
                    return [{
                        text: cleanText,
                        font: regularFont,
                        size: size,
                        color: color,
                        width: this.calculateTextWidth(cleanText, regularFont, size)
                    }];
                }

                // === ADVANCED PARSING LOGIC ===
                const segmentPatterns = [
                    { tag: 'b', font: boldFont, index: 1 },
                    { tag: 'i', font: italicFont, index: 2 },
                    { tag: 'code', font: regularFont, index: 3, sizeMultiplier: 0.9 }
                ];

                // Enhanced regex for better matching
                const regex = /(<b>(.*?)<\/b>|<i>(.*?)<\/i>|<code>(.*?)<\/code>)/g;
                let lastIndex = 0;
                let match;
                
                while ((match = regex.exec(text)) !== null) {
                    // === PROCESS TEXT BEFORE STYLED SEGMENT ===
                    if (match.index > lastIndex) {
                        const beforeText = text.substring(lastIndex, match.index);
                        const cleanBeforeText = beforeText.replace(/<[^>]*>/g, '');

                        if (cleanBeforeText && cleanBeforeText.length > 0) {
                            segments.push({
                                text: cleanBeforeText,
                                font: regularFont,
                                size: size,
                                color: color,
                                width: this.calculateTextWidth(cleanBeforeText, regularFont, size)
                            });
                        }
                    }

                    // === PROCESS STYLED SEGMENT ===
                    let styledSegment = null;
                    let segmentFont = regularFont;
                    let segmentSize = size;
                    let segmentText = '';
                    let segmentWidth = 0;

                    // Determine which type of segment we have
                    if (match[1] && match[1].startsWith('<b>')) {
                        segmentFont = boldFont || regularFont;
                        segmentText = match[2] || '';
                        segmentSize = size;
                    } else if (match[1] && match[1].startsWith('<i>')) {
                        segmentFont = italicFont || regularFont;
                        segmentText = match[3] || '';
                        segmentSize = size;
                    } else if (match[1] && match[1].startsWith('<code>')) {
                        segmentFont = regularFont; // Code uses regular font
                        segmentText = match[4] || '';
                        segmentSize = size * 0.9; // Code is slightly smaller
                    }

                    // === SEGMENT VALIDATION AND CREATION ===
                    if (segmentText && segmentText.length > 0) {
                        const cleanSegmentText = segmentText.replace(/<[^>]*>/g, '');

                        if (cleanSegmentText.length > 0) {
                            segmentWidth = this.calculateTextWidth(cleanSegmentText, segmentFont, segmentSize);

                            styledSegment = {
                                text: cleanSegmentText,
                                font: segmentFont,
                                size: segmentSize,
                                color: color,
                                width: segmentWidth
                            };

                            // Additional validation for code segments
                            if (match[1] && match[1].startsWith('<code>')) {
                                styledSegment.isCode = true;
                                styledSegment.backgroundColor = { r: 0.95, g: 0.95, b: 0.95 };
                            }
                        }
                    }

                    // === ADD VALIDATED SEGMENT ===
                    if (styledSegment) {
                        segments.push(styledSegment);
                    }
                    
                    lastIndex = regex.lastIndex;
                }

                // === PROCESS REMAINING TEXT ===
                if (lastIndex < text.length) {
                    const remainingText = text.substring(lastIndex);
                    const cleanRemainingText = remainingText.replace(/<[^>]*>/g, '');

                    if (cleanRemainingText && cleanRemainingText.length > 0) {
                        segments.push({
                            text: cleanRemainingText,
                            font: regularFont,
                            size: size,
                            color: color,
                            width: this.calculateTextWidth(cleanRemainingText, regularFont, size)
                        });
                    }
                }

                // === POST-PROCESSING VALIDATION ===
                const validSegments = segments.filter(segment => {
                    return segment &&
                           segment.text &&
                           typeof segment.text === 'string' &&
                           segment.font &&
                           segment.width &&
                           typeof segment.width === 'number' &&
                           segment.width >= 0;
                });

                return validSegments.length > 0 ? validSegments : [{
                    text: text.replace(/<[^>]*>/g, ''),
                    font: regularFont,
                    size: size,
                    color: color,
                    width: this.calculateTextWidth(text.replace(/<[^>]*>/g, ''), regularFont, size)
                }];
            },

            // === HELPER: CALCULATE TEXT WIDTH ===
            calculateTextWidth: function(text, font, size) {
                // === COMPREHENSIVE VALIDATION ===
                if (!text || typeof text !== 'string') return 0;
                if (!font || !font.widthOfTextAtSize) return text.length * (size || 12) * 0.6; // rough estimate
                if (!size || size <= 0) return 0;

                // === TEXT CLEANING ===
                const cleanText = text.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');

                if (cleanText.length === 0) return 0;

                // === WIDTH CALCULATION WITH FALLBACKS ===
                try {
                    const width = font.widthOfTextAtSize(cleanText, size);
                    if (typeof width === 'number' && width >= 0) {
                        return width;
                    }
                } catch (error) {
                    console.warn('Font width calculation failed:', error);
                }

                // === FALLBACK CALCULATION ===
                const avgCharWidth = size * 0.6; // rough average
                return cleanText.length * avgCharWidth;
            },

            wrapText: function(text, font, size, maxWidth) {
                // === COMPREHENSIVE INPUT VALIDATION ===
                if (!text && text !== 0) return [''];
                if (!font) {
                    console.warn('wrapText: No font provided');
                    return [''];
                }
                if (!size || size <= 0) {
                    console.warn('wrapText: Invalid font size');
                    return [''];
                }
                if (!maxWidth || maxWidth <= 0) {
                    // If no maxWidth, split on newlines only
                    if (typeof text === 'string') {
                        return text.split('\n').filter(line => line !== null);
                    } else {
                        return [String(text)];
                    }
                }

                // === ADVANCED TEXT PROCESSING ===
                let textString = String(text);

                // Handle null/undefined edge cases
                if (textString === 'null' || textString === 'undefined') {
                    textString = '';
                }

                // Remove control characters that might cause issues
                textString = textString.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');

                // Normalize whitespace
                textString = textString.replace(/\s+/g, ' ').trim();

                // Handle empty string after processing
                if (textString.length === 0) {
                    return [''];
                }

                // === INTELLIGENT WORD BREAKING LOGIC ===
                const words = [];
                let currentWord = '';

                for (let i = 0; i < textString.length; i++) {
                    const char = textString[i];

                    if (char === ' ') {
                        if (currentWord.length > 0) {
                            words.push(currentWord);
                            currentWord = '';
                        }
                        words.push(' '); // Preserve spaces as separate tokens
                    } else if (char === '\n') {
                        if (currentWord.length > 0) {
                            words.push(currentWord);
                            currentWord = '';
                        }
                        words.push('\n'); // Preserve newlines
                    } else if (char === '\t') {
                        if (currentWord.length > 0) {
                            words.push(currentWord);
                            currentWord = '';
                        }
                        words.push('    '); // Convert tabs to spaces
                    } else {
                        currentWord += char;
                    }
                }

                if (currentWord.length > 0) {
                    words.push(currentWord);
                }

                // === SOPHISTICATED LINE WRAPPING ===
                const lines = [];
                let currentLine = '';
                let currentLineWidth = 0;

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];

                    // Handle newlines immediately
                    if (word === '\n') {
                        if (currentLine.trim().length > 0) {
                            lines.push(currentLine.trim());
                        }
                        currentLine = '';
                        currentLineWidth = 0;
                        continue;
                    }

                    // Handle spaces
                    if (word === ' ') {
                        if (currentLine.length > 0) {
                            const testLine = currentLine + word;
                            const testWidth = font.widthOfTextAtSize(testLine, size);

                            if (testWidth <= maxWidth) {
                                currentLine = testLine;
                                currentLineWidth = testWidth;
                            } else {
                                // Space would exceed width, move to next line
                                lines.push(currentLine.trim());
                                currentLine = '';
                                currentLineWidth = 0;
                            }
                        }
                        continue;
                    }

                    // Handle regular words
                    const testLine = currentLine + (currentLine.length > 0 && !currentLine.endsWith(' ') ? ' ' : '') + word;
                    const testWidth = font.widthOfTextAtSize(testLine, size);

                    if (testWidth <= maxWidth) {
                        currentLine = testLine;
                        currentLineWidth = testWidth;
                    } else {
                        // Word doesn't fit, try to break the word
                        if (currentLine.trim().length > 0) {
                            lines.push(currentLine.trim());
                            currentLine = '';
                            currentLineWidth = 0;
                        }

                        // Try to fit the word by breaking it
                        const brokenWord = this.breakLongWord(word, font, size, maxWidth);
                        if (brokenWord.length > 1) {
                            // Word was broken, add first part
                            currentLine = brokenWord[0];
                            currentLineWidth = font.widthOfTextAtSize(brokenWord[0], size);

                            // Add remaining parts as separate lines if needed
                            for (let j = 1; j < brokenWord.length; j++) {
                                lines.push(currentLine.trim());
                                currentLine = brokenWord[j];
                                currentLineWidth = font.widthOfTextAtSize(brokenWord[j], size);
                            }
                        } else {
                            // Word couldn't be broken, add it anyway (might overflow)
                            currentLine = word;
                            currentLineWidth = font.widthOfTextAtSize(word, size);
                        }
                    }
                }

                // Add final line if it has content
                if (currentLine.trim().length > 0) {
                    lines.push(currentLine.trim());
                }

                // === POST-PROCESSING VALIDATION ===
                const validLines = lines.filter(line =>
                    line !== null &&
                    line !== undefined &&
                    typeof line === 'string'
                );

                return validLines.length > 0 ? validLines : [''];
            },

            // === HELPER: BREAK LONG WORDS ===
            breakLongWord: function(word, font, size, maxWidth) {
                const lines = [];
                let currentLine = '';

                for (let i = 0; i < word.length; i++) {
                    const testLine = currentLine + word[i];
                    const testWidth = font.widthOfTextAtSize(testLine, size);

                    if (testWidth <= maxWidth) {
                        currentLine = testLine;
                    } else {
                        if (currentLine.length > 0) {
                            lines.push(currentLine);
                            currentLine = word[i];
                        } else {
                            // Single character doesn't fit, add it anyway
                            lines.push(word[i]);
                        }
                    }
                }

                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }

                return lines;
            },
            
            // --- NEW: pdf-lib Asset Fetching ---
            
            fetchFont: async function(url) {
                try {
                    const res = await fetch(url);
                    if (!res.ok) {
                        throw new Error(`Font fetch failed with status ${res.status}: ${url}`);
                    }
                    return await res.arrayBuffer();
                } catch (err) {
                    console.error("Font fetch failed:", err);
                    this.showGlobalError(`Failed to fetch font: ${url}. Check console. Make sure the 'fonts' folder is in the same directory as this HTML file.`);
                    return null;
                }
            },
            
            fetchAndEmbedImage: async function(pdfDoc, url, targetWidthPts) {
                if (!url) return null;
                try {
                    const res = await fetch(url); 
                    if (!res.ok) {
                         throw new Error(`Image fetch failed with status ${res.status}: ${url}`);
                    }
                    const blob = await res.blob();

                    // If we have a target width (in points), cap the pixel width to ~300 DPI for print
                    if (targetWidthPts && typeof targetWidthPts === 'number' && targetWidthPts > 0 && typeof window !== 'undefined') {
                        const img = await new Promise((resolve, reject) => {
                            const image = new Image();
                            image.onload = () => resolve(image);
                            image.onerror = reject;
                            image.src = URL.createObjectURL(blob);
                        });

                        const targetPx = Math.floor((targetWidthPts * 300) / 72); // 300 DPI
                        const scale = Math.min(1, targetPx / img.width);

                        if (scale < 1) {
                            const canvas = document.createElement('canvas');
                            canvas.width = Math.max(1, Math.floor(img.width * scale));
                            canvas.height = Math.max(1, Math.floor(img.height * scale));
                            const ctx = canvas.getContext('2d');
                            ctx.imageSmoothingQuality = 'high';
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            const optimizedBlob = await new Promise(resolve => canvas.toBlob(resolve, blob.type === 'image/jpeg' ? 'image/jpeg' : 'image/png', 0.92));
                            const optimizedBytes = optimizedBlob ? await optimizedBlob.arrayBuffer() : await blob.arrayBuffer();
                            const uint8opt = new Uint8Array(optimizedBytes);
                            if (uint8opt[0] === 0xFF && uint8opt[1] === 0xD8 && uint8opt[2] === 0xFF) {
                                return await pdfDoc.embedJpg(optimizedBytes);
                            }
                            return await pdfDoc.embedPng(optimizedBytes);
                        }
                    }

                    const imageBytes = await blob.arrayBuffer();
                    const uint8 = new Uint8Array(imageBytes);
                    if (uint8[0] === 0xFF && uint8[1] === 0xD8 && uint8[2] === 0xFF) {
                        return await pdfDoc.embedJpg(imageBytes);
                    } else if (uint8[0] === 0x89 && uint8[1] === 0x50 && uint8[2] === 0x4E && uint8[3] === 0x47) {
                         return await pdfDoc.embedPng(imageBytes);
                    }
                    console.warn(`Unknown image type for ${url}, attempting to embed as PNG.`);
                    return await pdfDoc.embedPng(imageBytes);
                } catch (err) {
                     console.error(`Failed to fetch or embed image: ${url}`, err);
                     return null;
                }
            },

            /**
             * === NEW: DYNAMIC FONT LOADER ===
             * Loads and embeds fonts based on the selected family key.
             */
            loadFonts: async function(pdfDoc, fontFamilyKey = 'geist') {
                const family = this.fontMap[fontFamilyKey] || this.fontMap['geist'];
                
                const [regBytes, lightBytes, mediumBytes, semiboldBytes, boldBytes, extraboldBytes, blackBytes, thinBytes, extralightBytes, italicBytes] = await Promise.all([
                    this.fetchFont(family.regular),
                    this.fetchFont(family.light),
                    this.fetchFont(family.medium),
                    this.fetchFont(family.semibold),
                    this.fetchFont(family.bold),
                    this.fetchFont(family.extrabold),
                    this.fetchFont(family.black),
                    this.fetchFont(family.thin),
                    this.fetchFont(family.extralight),
                    this.fetchFont(family.italic)
                ]);
                
                if (!regBytes || !lightBytes || !italicBytes) {
                    throw new Error("One or more essential fonts failed to load.");
                }

                const [regular, light, medium, semibold, bold, extrabold, black, thin, extralight, italic] = await Promise.all([
                    pdfDoc.embedFont(regBytes),
                    pdfDoc.embedFont(lightBytes),
                    mediumBytes ? pdfDoc.embedFont(mediumBytes) : pdfDoc.embedFont(regBytes),
                    semiboldBytes ? pdfDoc.embedFont(semiboldBytes) : pdfDoc.embedFont(boldBytes || regBytes),
                    boldBytes ? pdfDoc.embedFont(boldBytes) : pdfDoc.embedFont(regBytes),
                    extraboldBytes ? pdfDoc.embedFont(extraboldBytes) : pdfDoc.embedFont(boldBytes || regBytes),
                    blackBytes ? pdfDoc.embedFont(blackBytes) : pdfDoc.embedFont(boldBytes || regBytes),
                    thinBytes ? pdfDoc.embedFont(thinBytes) : pdfDoc.embedFont(lightBytes),
                    extralightBytes ? pdfDoc.embedFont(extralightBytes) : pdfDoc.embedFont(lightBytes),
                    pdfDoc.embedFont(italicBytes)
                ]);
                
                return { regular, light, medium, semibold, bold, extrabold, black, thin, extralight, italic };
            },

            getBaseFontSize: function(finalSettings) {
                switch(finalSettings.fontSize) {
                    case 'small': return 10;
                    case 'large': return 14;
                    case 'medium':
                    default:
                        return 12;
                }
            },

            /**
             * === NEW: DRAW TABLE ===
             * Draws a table with proper formatting and borders
             */
            // === ENHANCED: Draw table with comprehensive formatting ===
            drawTable: function(tableData, options) {
                const { page, font, size, color, x, y, width, titleColor } = options;
                const { rgb } = PDFLib;

                // === COMPREHENSIVE INPUT VALIDATION ===
                if (!page) {
                    console.warn('drawTable: Missing page parameter');
                    return y;
                }

                if (!tableData || !tableData.rows || tableData.rows.length === 0) {
                    return y;
                }

                const { width: pageWidth, height: pageHeight } = page.getSize();

                // === ADVANCED BOUNDARY CALCULATION ===
                const leftMargin = 72;
                const rightMargin = 72;
                const topMargin = 72;
                const bottomMargin = 72;
                const usableWidth = pageWidth - leftMargin - rightMargin;
                const usableHeight = pageHeight - topMargin - bottomMargin;

                // === INTELLIGENT POSITIONING ===
                const effectiveWidth = Math.min(width || usableWidth, usableWidth);
                const effectiveX = Math.max(x || leftMargin, leftMargin);
                const effectiveY = Math.max(y || pageHeight - topMargin, topMargin);

                // === TABLE STYLING CONSTANTS ===
                const cellPadding = 8;
                const borderWidth = 1;
                const minCellWidth = 50;
                const maxCellWidth = effectiveWidth * 0.6;

                // === DYNAMIC COLOR CALCULATION ===
                let headerColor, textColor, borderColor, headerBgColor;

                // Use theme color system with fallbacks
                if (titleColor && typeof titleColor === 'object' && titleColor.r !== undefined) {
                    headerColor = titleColor;
                } else {
                    headerColor = hexToRgb(themeColorHex);
                }

                if (color && typeof color === 'object' && color.r !== undefined) {
                    textColor = color;
                } else {
                    textColor = hexToRgb(themeColorTextHex);
                }

                // Use secondary color for borders and backgrounds
                borderColor = hexToRgb(themeColorSecondaryHex);
                headerBgColor = hexToRgb(themeColorBgHex);

                // === SOPHISTICATED COLUMN WIDTH CALCULATION ===
                const colCount = Math.max(...tableData.rows.map(row => {
                    if (row && Array.isArray(row)) {
                        return row.length;
                    }
                    return 0;
                }));

                if (colCount <= 0) {
                    return effectiveY;
                }

                // Initialize column widths with intelligent distribution
                const colWidths = new Array(colCount).fill(effectiveWidth / colCount);

                // === ADVANCED CONTENT ANALYSIS ===
                tableData.rows.forEach((row, rowIndex) => {
                    if (!row || !Array.isArray(row)) return;

                    row.forEach((cell, colIndex) => {
                        if (!cell || !cell.text) return;

                        const cellText = String(cell.text).trim();
                        if (cellText.length === 0) return;

                        // Calculate text width with validation
                        let textWidth;
                        try {
                            textWidth = font.widthOfTextAtSize(cellText, size);
                        } catch (error) {
                            console.warn('Text width calculation failed:', error);
                            textWidth = cellText.length * size * 0.6; // fallback
                        }

                        // Apply intelligent column width adjustment
                        if (textWidth > 0) {
                            const requiredWidth = textWidth + (cellPadding * 2) + borderWidth;
                            const currentWidth = colWidths[colIndex] || 0;

                            if (requiredWidth > currentWidth) {
                                // Increase column width if needed
                                const newWidth = Math.min(requiredWidth, maxCellWidth);
                                if (newWidth > currentWidth) {
                                    colWidths[colIndex] = newWidth;
                                }
                            }
                        }
                    });
                });

                // === COLUMN WIDTH NORMALIZATION ===
                const totalCalculatedWidth = colWidths.reduce((sum, width) => sum + (width || 0), 0);

                if (totalCalculatedWidth > effectiveWidth) {
                    const scale = effectiveWidth / totalCalculatedWidth;
                    colWidths.forEach((width, index) => {
                        if (width && width > 0) {
                            colWidths[index] = width * scale;
                        }
                    });
                }

                // Ensure minimum column widths
                colWidths.forEach((width, index) => {
                    if (width < minCellWidth) {
                        colWidths[index] = minCellWidth;
                    }
                });

                // === ADVANCED TABLE RENDERING ===
                let currentY = effectiveY;
                let isFirstRow = true;
                const minRowHeight = size + (cellPadding * 2) + borderWidth;

                tableData.rows.forEach((row, rowIndex) => {
                    if (!row || !Array.isArray(row)) return;

                    // === ROW HEIGHT CALCULATION ===
                    let maxRowHeight = minRowHeight;

                    row.forEach((cell, colIndex) => {
                        if (!cell || !cell.text) return;

                        const cellText = String(cell.text).trim();
                        if (cellText.length === 0) return;

                        const availableWidth = (colWidths[colIndex] || minCellWidth) - (cellPadding * 2) - borderWidth;

                        // Calculate cell height with error handling
                        let cellHeight;
                        try {
                            const lines = this.wrapText(cellText, font, size, Math.max(availableWidth, 20));
                            cellHeight = (lines.length * (size * 1.2)) + (cellPadding * 2) + borderWidth;
                        } catch (error) {
                            console.warn('Cell height calculation failed:', error);
                            cellHeight = minRowHeight;
                        }

                        maxRowHeight = Math.max(maxRowHeight, cellHeight);
                    });

                    // === BOUNDARY VALIDATION ===
                    const tableHeight = tableData.rows.length * maxRowHeight;
                    const wouldExceedBottom = currentY - tableHeight < bottomMargin;

                    if (wouldExceedBottom) {
                        console.warn('Table would exceed page boundaries');
                        return currentY;
                    }

                    // === HEADER BACKGROUND RENDERING ===
                    if (isFirstRow) {
                        try {
                            page.drawRectangle({
                                x: effectiveX,
                                y: currentY - maxRowHeight,
                                width: effectiveWidth,
                                height: maxRowHeight,
                                color: headerBgColor,
                            });
                        } catch (error) {
                            console.error('Header background rendering failed:', error);
                        }
                    }

                    // === CELL RENDERING LOOP ===
                    let currentX = effectiveX;

                    row.forEach((cell, colIndex) => {
                        const cellWidth = colWidths[colIndex] || minCellWidth;

                        // === CELL BOUNDARY VALIDATION ===
                        const cellRightEdge = currentX + cellWidth;
                        const wouldExceedRight = cellRightEdge > pageWidth - rightMargin;

                        if (wouldExceedRight) {
                            console.warn(`Cell ${colIndex} would exceed right boundary`);
                            return;
                        }

                        // === CELL BORDER RENDERING ===
                        try {
                            page.drawRectangle({
                                x: currentX,
                                y: currentY - maxRowHeight,
                                width: cellWidth,
                                height: maxRowHeight,
                                borderColor: borderColor,
                                borderWidth: borderWidth,
                            });
                        } catch (error) {
                            console.error('Cell border rendering failed:', error);
                        }

                        // === CELL TEXT RENDERING ===
                        if (cell && cell.text && String(cell.text).trim().length > 0) {
                            const cellText = String(cell.text).trim();
                            const textFont = isFirstRow && cell.style && cell.style.bold ?
                                (boldFont || font) : font;
                            const textSize = isFirstRow ? size : size;
                            const cellTextColor = isFirstRow ? headerColor : textColor;

                            try {
                                this.drawText(cellText, {
                                    page,
                                    font: textFont,
                                    size: textSize,
                                    color: cellTextColor,
                                    y: currentY - cellPadding - borderWidth,
                                    maxWidth: Math.max(cellWidth - (cellPadding * 2) - (borderWidth * 2), 10),
                                    align: 'left',
                                    margin: currentX + cellPadding + borderWidth,
                                    lineHeight: size * 1.2
                                });
                            } catch (error) {
                                console.error('Cell text rendering failed:', error);

                                // === FALLBACK CELL TEXT RENDERING ===
                                try {
                                    const fallbackText = cellText.replace(/[^\x20-\x7E]/g, '?');
                                    page.drawText(fallbackText, {
                                        x: currentX + cellPadding + borderWidth,
                                        y: currentY - cellPadding - borderWidth,
                                        font: font,
                                        size: textSize,
                                        color: cellTextColor
                                    });
                                } catch (fallbackError) {
                                    console.error('Fallback cell text rendering failed:', fallbackError);
                                }
                            }
                        }

                        currentX += cellWidth;
                    });

                    currentY -= maxRowHeight;
                    isFirstRow = false;
                });

                return currentY;
            },

            /**
             * === UPDATED: RENDER MD TO PDF ===
             * Now includes an 'options' object with 'isToc' flag.
             */
            renderMdToPdfDoc: async function(pdfDoc, markdownContent, finalSettings, fonts, options = {}) {
                const { isToc = false, skipCoverPage = false } = options; // NEW: skipCoverPage flag
                
                const { PDFDocument, rgb, PageSizes } = PDFLib;
                const { regular, light, italic } = fonts;

                // Alignment and spacing settings
                const paragraphAlign = (finalSettings.textAlignment || 'left');
                const spacingMode = (finalSettings.paragraphSpacing || 'normal');
                const spacingConfig = (mode) => {
                    if (mode === 'compact') return { line: 1.3, gap: 0.3 };
                    if (mode === 'relaxed') return { line: 1.6, gap: 0.8 };
                    return { line: 1.4, gap: 0.5 }; // normal
                };
                const spacing = spacingConfig(spacingMode);
                
                // === ENHANCED THEME COLOR SYSTEM ===
                const themeColorHex = finalSettings.themeColor || '#268ca7';
                const themeColorSecondaryHex = finalSettings.themeColorSecondary || '#1e6a80';
                const themeColorTextHex = finalSettings.themeColorText || '#333333';
                const themeColorBgHex = finalSettings.themeColorBg || '#f7f8fa';

                // Convert hex colors to RGB
                const hexToRgb = (hex) => {
                    if (!hex || typeof hex !== 'string') return rgb(0, 0, 0);
                    const cleanHex = hex.replace('#', '');
                    if (cleanHex.length !== 6) return rgb(0, 0, 0);

                    return rgb(
                        parseInt(cleanHex.substr(0, 2), 16) / 255,
                        parseInt(cleanHex.substr(2, 2), 16) / 255,
                        parseInt(cleanHex.substr(4, 2), 16) / 255
                    );
                };

                const titleColor = hexToRgb(themeColorHex);
                const secondaryColor = hexToRgb(themeColorSecondaryHex);
                const textColor = hexToRgb(themeColorTextHex);
                const backgroundColor = hexToRgb(themeColorBgHex);
                const baseFontSize = this.getBaseFontSize(finalSettings);
                
                const [pageWidth, pageHeight] = PageSizes.A4;
                const margin = 72; // 1 inch
                const maxWidth = pageWidth - (margin * 2);

                let page;
                let currentY;
                let pageCount = 1;
                
                // === FIXED: Cover page logic - only add if not skipping and not TOC ===
                if (!isToc && !skipCoverPage) {
                    page = pdfDoc.addPage(PageSizes.A4);
                    currentY = pageHeight - margin;

                    // Draw Logo
                    if (finalSettings.logoUrl) {
                        const logoImage = await this.fetchAndEmbedImage(pdfDoc, finalSettings.logoUrl, 200);
                        if (logoImage) {
                            const dims = logoImage.scale(1); 
                            const logoWidth = Math.min(dims.width, 200);
                            const logoHeight = (logoWidth / dims.width) * dims.height;
                            
                            page.drawImage(logoImage, {
                                x: (pageWidth - logoWidth) / 2,
                                y: currentY - logoHeight,
                                width: logoWidth,
                                height: logoHeight,
                            });
                            currentY -= (logoHeight + 36);
                        } else {
                            currentY -= 72;
                        }
                    } else {
                        currentY -= 72;
                    }
                    
                    // Draw Titles (centered)
                    currentY = this.drawText(finalSettings.courseTitle, { 
                        page, font: light, size: 28, color: titleColor, y: currentY, maxWidth: maxWidth, align: 'center'
                    });
                    currentY -= 12;
                    currentY = this.drawText(finalSettings.instructorName, { 
                        page, font: regular, size: 18, color: textColor, y: currentY, maxWidth: maxWidth, align: 'center'
                    });
                    
                    // Add footer to cover page
                    const footerY = margin / 2;
                    this.drawText(finalSettings.footerText, {
                        page, font: regular, size: 9, color: rgb(0.5, 0.5, 0.5), 
                        y: footerY, maxWidth: maxWidth, align: 'left', margin: margin
                    });
                    if (finalSettings.includePageNumbers !== false) {
                        this.drawText(String(pageCount), {
                            page, font: regular, size: 9, color: rgb(0.5, 0.5, 0.5), 
                            y: footerY, maxWidth: maxWidth, align: 'right', margin: margin
                        });
                    }
                    pageCount++;
                }

                // --- Content Pages ---
                // Add a new page for content
                    page = pdfDoc.addPage(PageSizes.A4);
                currentY = pageHeight - margin;

                const addPage = () => {
                    // Add footer to current page before creating new one
                    const footerY = margin / 2;
                    this.drawText(finalSettings.footerText, {
                        page, font: regular, size: 9, color: rgb(0.5, 0.5, 0.5), 
                        y: footerY, maxWidth: maxWidth, align: 'left', margin: margin
                    });
                    if (finalSettings.includePageNumbers !== false) {
                        this.drawText(String(pageCount), {
                            page, font: regular, size: 9, color: rgb(0.5, 0.5, 0.5), 
                            y: footerY, maxWidth: maxWidth, align: 'right', margin: margin
                        });
                    }
                    
                    page = pdfDoc.addPage(PageSizes.A4);
                    // Running header removed per user request
                    pageCount++;
                    return pageHeight - margin;
                };

                marked.setOptions({ breaks: true, gfm: true, tables: true, smartLists: true, smartypants: true });
                const tokens = marked.lexer(markdownContent);

                // Helper function to parse inline markdown (bold, italic, etc.)
                const parseInlineMarkdown = (text) => {
                    if (!text) return '';
                    // Parse bold text **text** -> <b>text</b>
                    let parsed = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
                    // Parse italic text *text* -> <i>text</i>
                    parsed = parsed.replace(/\*(.*?)\*/g, '<i>$1</i>');
                    // Parse inline code `text` -> <code>text</code>
                    parsed = parsed.replace(/`(.*?)`/g, '<code>$1</code>');
                    return parsed;
                };

                // === SMART PAGE BREAK SYSTEM ===
                const checkY = (requiredHeight, options = {}) => {
                    const {
                        preventOrphan = true,
                        keepWithNext = false,
                        minSpaceAfter = 0,
                        forceBreak = false
                    } = options;

                    const footerHeight = 30; // Space for footer
                    const safetyBuffer = 15; // Extra safety margin
                    const minContentHeight = baseFontSize * 1.5; // Minimum content that should remain

                    let availableSpace = currentY - margin - footerHeight - safetyBuffer;

                    // If we need to keep content with next element, reserve more space
                    if (keepWithNext) {
                        availableSpace -= minContentHeight;
                    }

                    // For orphan prevention, ensure we don't leave just a few lines
                    if (preventOrphan && availableSpace < requiredHeight + minContentHeight) {
                        availableSpace = 0; // Force page break
                    }

                    // Force break if explicitly requested
                    if (forceBreak || availableSpace < requiredHeight + minSpaceAfter) {
                        currentY = addPage();
                    }
                    return currentY;
                };

                // Enhanced table height calculation
                const calculateTableHeight = (tableData, font, size, maxWidth) => {
                    if (!tableData || !tableData.rows || tableData.rows.length === 0) return 0;

                    let totalHeight = 0;
                    const cellPadding = 8;
                    const borderWidth = 1;

                    // Calculate column widths based on content
                    const colCount = Math.max(...tableData.rows.map(row => row.length));
                    const colWidths = new Array(colCount).fill(maxWidth / colCount);

                    // Refine column widths based on content
                    tableData.rows.forEach(row => {
                        row.forEach((cell, colIndex) => {
                            if (cell && cell.text) {
                                const cellText = cell.text.trim();
                                const textWidth = font.widthOfTextAtSize(cellText, size);
                                if (textWidth > colWidths[colIndex] - (cellPadding * 2)) {
                                    // Redistribute width if this column needs more space
                                    const excess = textWidth - (colWidths[colIndex] - (cellPadding * 2));
                                    colWidths[colIndex] = Math.min(textWidth + (cellPadding * 2), maxWidth * 0.4);
                                }
                            }
                        });
                    });

                    // Normalize column widths to fit maxWidth
                    const totalWidth = colWidths.reduce((sum, width) => sum + width, 0);
                    if (totalWidth > maxWidth) {
                        const scale = maxWidth / totalWidth;
                        colWidths.forEach((width, index) => {
                            colWidths[index] = width * scale;
                        });
                    }

                    // Calculate height for each row
                    tableData.rows.forEach(row => {
                        let maxRowHeight = size + (cellPadding * 2) + borderWidth;

                        row.forEach((cell, colIndex) => {
                            if (cell && cell.text) {
                                const cellText = cell.text.trim();
                                const availableWidth = colWidths[colIndex] - (cellPadding * 2) - borderWidth;
                                const lines = this.wrapText(cellText, font, size, availableWidth);
                                const cellHeight = (lines.length * (size * 1.2)) + (cellPadding * 2) + borderWidth;
                                maxRowHeight = Math.max(maxRowHeight, cellHeight);
                            }
                        });

                        totalHeight += maxRowHeight;
                    });

                    return totalHeight + 20; // Add some extra padding
                };

                // Smart table splitting for large tables
                const splitTableIfNeeded = (tableData, font, size, maxWidth, maxPageHeight) => {
                    const tableHeight = calculateTableHeight(tableData, font, size, maxWidth);

                    if (tableHeight <= maxPageHeight) {
                        return [tableData]; // Table fits on one page
                    }

                    // Split table into chunks
                    const chunks = [];
                    const headerRow = tableData.rows[0]; // Assume first row is header
                    const dataRows = tableData.rows.slice(1);

                    let currentChunk = { rows: [headerRow] };
                    let currentHeight = calculateTableHeight({ rows: [headerRow] }, font, size, maxWidth);
                    const maxChunkHeight = maxPageHeight * 0.8; // Leave some margin

                    for (const row of dataRows) {
                        const testChunk = { rows: [...currentChunk.rows, row] };
                        const testHeight = calculateTableHeight(testChunk, font, size, maxWidth);

                        if (testHeight > maxChunkHeight) {
                            // Add current chunk and start new one
                            chunks.push(currentChunk);
                            currentChunk = { rows: [headerRow, row] }; // Repeat header
                            currentHeight = calculateTableHeight(currentChunk, font, size, maxWidth);
                        } else {
                            currentChunk.rows.push(row);
                            currentHeight = testHeight;
                        }
                    }

                    if (currentChunk.rows.length > 1) {
                        chunks.push(currentChunk);
                    }

                    return chunks;
                };

                for (const token of tokens) {
                    let textHeight = 0;
                    
                    switch (token.type) {
                        case 'heading':
                            let headingSize;
                            const headingStyle = (finalSettings.headingStylePreset || 'clean');
                            if (token.depth === 1) headingSize = 24;
                            else if (token.depth === 2) headingSize = 18;
                            else if (token.depth === 3) headingSize = 14;
                            else headingSize = baseFontSize;

                            // Get the selected header font weight
                            const headerFontWeight = finalSettings.headerFontWeight || 'semibold';
                            let headerFont;
                            switch(headerFontWeight) {
                                case 'thin': headerFont = fonts.thin || fonts.light; break;
                                case 'extralight': headerFont = fonts.extralight || fonts.light; break;
                                case 'light': headerFont = fonts.light; break;
                                case 'regular': headerFont = fonts.regular; break;
                                case 'medium': headerFont = fonts.medium || fonts.regular; break;
                                case 'semibold': headerFont = fonts.semibold || fonts.bold || fonts.regular; break;
                                case 'bold': headerFont = fonts.bold || fonts.regular; break;
                                case 'extrabold': headerFont = fonts.extrabold || fonts.bold || fonts.regular; break;
                                case 'black': headerFont = fonts.black || fonts.bold || fonts.regular; break;
                                default: headerFont = fonts.semibold || fonts.bold || fonts.regular;
                            }

                            // Adjust sizes/margins by style preset
                            if (headingStyle === 'bold') {
                                headingSize += (token.depth === 1 ? 2 : 1);
                            } else if (headingStyle === 'minimalist') {
                                headingSize -= (token.depth >= 3 ? 1 : 0);
                            }

                            // Calculate actual text height including wrapping
                            const headingLines = this.wrapText(token.text, headerFont, headingSize, maxWidth);
                            textHeight = headingLines.length * (headingSize * 1.4);

                            // Smart page break for headings - prevent orphan headings
                            let headingSpacing = token.depth === 1 ? 32 : (token.depth === 2 ? 22 : 14);
                            if (headingStyle === 'bold') headingSpacing += 2;
                            if (headingStyle === 'minimalist') headingSpacing -= 2;
                            currentY = checkY(textHeight + headingSpacing, {
                                preventOrphan: true,
                                keepWithNext: true,
                                minSpaceAfter: baseFontSize
                            });

                            // Add extra space before H1 headings and force new page if needed
                            if (token.depth === 1 && currentY < pageHeight - margin - 100) {
                                currentY = checkY(0, { forceBreak: true });
                            }

                            currentY = this.drawText(token.text, {
                                page, font: headerFont, size: headingSize, color: titleColor,
                                y: currentY, maxWidth: maxWidth, align: 'left', margin: margin
                            });
                            currentY -= headingSpacing;
                            break;
                            
                        case 'paragraph':
                            const lines = this.wrapText(token.text, regular, baseFontSize, maxWidth);
                            textHeight = lines.length * (baseFontSize * spacing.line);

                            // Smart page break for paragraphs - prevent orphans
                            currentY = checkY(textHeight, {
                                preventOrphan: true,
                                minSpaceAfter: baseFontSize * spacing.gap
                            });

                            // Use styled text rendering for paragraphs to handle bold/italic
                            currentY = this.drawStyledText(token.text, {
                                page, font: regular, boldFont: light, italicFont: italic, size: baseFontSize, color: textColor,
                                y: currentY, maxWidth: maxWidth, align: paragraphAlign, margin: margin, lineHeight: baseFontSize * spacing.line
                            });
                            currentY -= (baseFontSize * spacing.gap);
                            break;

                        case 'list':
                            let listY = currentY;
                            let itemIndex = 0;

                            // Calculate total list height for smart page breaking
                            let totalListHeight = 0;
                            const itemHeights = [];

                            for (const item of token.items) {
                                const bullet = token.ordered ? `${itemIndex + 1}. ` : 'â¢ ';
                                const itemText = bullet + item.text;
                                const itemLines = this.wrapText(itemText, regular, baseFontSize, maxWidth - 20);
                                const itemHeight = itemLines.length * (baseFontSize * spacing.line);
                                itemHeights.push(itemHeight);
                                totalListHeight += itemHeight + (baseFontSize * spacing.gap);
                            }

                            // Check if entire list fits, if not, be smart about breaking
                            const availableSpace = listY - margin - 30; // 30 for footer + buffer

                            if (totalListHeight > availableSpace && availableSpace > baseFontSize * 3) {
                                // Try to fit as many items as possible
                                let accumulatedHeight = 0;
                                let itemsToKeep = 0;

                                for (let i = 0; i < itemHeights.length; i++) {
                                    if (accumulatedHeight + itemHeights[i] + (baseFontSize * spacing.gap) <= availableSpace - baseFontSize * 2) {
                                        accumulatedHeight += itemHeights[i] + (baseFontSize * spacing.gap);
                                        itemsToKeep++;
                                    } else {
                                        break;
                                    }
                                }

                                if (itemsToKeep === 0) {
                                    // Not enough space for even one item, start new page
                                    listY = addPage();
                                }
                            }
                            
                            for (const item of token.items) {
                                const bullet = token.ordered ? `${itemIndex + 1}. ` : 'â¢ ';
                                const itemText = bullet + item.text;
                                const itemLines = this.wrapText(itemText, regular, baseFontSize, maxWidth - 20);
                                textHeight = itemLines.length * (baseFontSize * spacing.line);

                                // Smart page break for list items
                                if (listY - textHeight - 15 < margin) {
                                    listY = addPage();
                                }

                                listY = this.drawStyledText(itemText, {
                                    page, font: regular, boldFont: light, italicFont: italic, size: baseFontSize, color: textColor,
                                    y: listY, maxWidth: maxWidth - 20, align: paragraphAlign, margin: margin + 20, lineHeight: baseFontSize * spacing.line
                                });
                                listY -= (baseFontSize * spacing.gap);
                                itemIndex++;
                            }
                            currentY = listY;
                            break;

                        case 'blockquote':
                            const bqLines = this.wrapText(token.text, italic, baseFontSize, maxWidth - 20);
                            textHeight = bqLines.length * (baseFontSize * 1.4) + 10; // Add padding

                            // Smart page break for blockquotes
                            currentY = checkY(textHeight, {
                                preventOrphan: true,
                                minSpaceAfter: baseFontSize
                            });

                            page.drawRectangle({
                                x: margin,
                                y: currentY - textHeight - 5,
                                width: maxWidth,
                                height: textHeight + 10,
                                color: rgb(0.95, 0.95, 0.95),
                            });
                            currentY -= 5;
                            currentY = this.drawText(token.text, {
                                page, font: italic, size: baseFontSize, color: rgb(0.2, 0.2, 0.2),
                                y: currentY, maxWidth: maxWidth - 20, align: 'left', margin: margin + 10, lineHeight: baseFontSize * 1.4
                            });
                            currentY -= (baseFontSize + 5);
                            break;

                        case 'image':
                            const img = await this.fetchAndEmbedImage(pdfDoc, token.href, maxWidth);
                            if (img) {
                                const dims = img.scale(1);
                                const imgWidth = Math.min(dims.width, maxWidth);
                                const imgHeight = (imgWidth / dims.width) * dims.height;
                                const totalImageHeight = imgHeight + 24; // Add padding

                                // Smart page break for images - ensure image fits with some context
                                currentY = checkY(totalImageHeight, {
                                    preventOrphan: true,
                                    minSpaceAfter: baseFontSize
                                });

                                page.drawImage(img, {
                                    x: (pageWidth - imgWidth) / 2,
                                    y: currentY - imgHeight,
                                    width: imgWidth,
                                    height: imgHeight,
                                });
                                currentY -= (imgHeight + 24);
                            }
                            break;
                            
                        case 'space':
                            currentY -= (baseFontSize * 1.4);
                            break;
                            
                        case 'hr':
                            currentY = checkY(12, {
                                preventOrphan: true,
                                minSpaceAfter: baseFontSize
                            });
                            page.drawLine({
                                start: { x: margin, y: currentY - 6 },
                                end: { x: pageWidth - margin, y: currentY - 6 },
                                thickness: 1,
                                color: rgb(0.8, 0.8, 0.8),
                            });
                            currentY -= 12;
                            break;

                        case 'table':
                            // Convert table tokens to our format
                            const tableData = {
                                rows: token.rows.map(row =>
                                    row.map(cell => ({
                                        text: cell.text || '',
                                        style: cell.style || {}
                                    }))
                                )
                            };

                            // Calculate table height and split if needed
                            const maxPageHeight = pageHeight - margin - 50; // Leave space for footer
                            const tableChunks = splitTableIfNeeded(tableData, regular, baseFontSize, maxWidth, maxPageHeight);

                            for (let chunkIndex = 0; chunkIndex < tableChunks.length; chunkIndex++) {
                                const chunk = tableChunks[chunkIndex];
                                const chunkHeight = calculateTableHeight(chunk, regular, baseFontSize, maxWidth);

                                // Smart page break for table chunks
                                currentY = checkY(chunkHeight, {
                                    preventOrphan: true,
                                    minSpaceAfter: baseFontSize
                                });

                                // Draw table
                                this.drawTable(chunk, {
                                    page,
                                    font: regular,
                                    size: baseFontSize,
                                    color: textColor,
                                    x: margin,
                                    y: currentY,
                                    width: maxWidth,
                                    titleColor: titleColor
                                });

                                currentY -= chunkHeight;

                                // Add continuation indicator if there are more chunks
                                if (chunkIndex < tableChunks.length - 1) {
                                    currentY = this.drawText('(Table continues on next page)', {
                                        page,
                                        font: italic,
                                        size: baseFontSize * 0.8,
                                        color: rgb(0.5, 0.5, 0.5),
                                        y: currentY,
                                        maxWidth: maxWidth,
                                        align: 'center',
                                        margin: margin
                                    });
                                    currentY -= baseFontSize * 1.5;
                                }
                            }
                            break;

                        default:
                            console.log('Unhandled token type:', token.type, token);
                    }
                }
                
                // Draw footer on the last page
                const footerY = margin / 2;
                this.drawText(finalSettings.footerText, {
                    page, font: regular, size: 9, color: rgb(0.5, 0.5, 0.5), 
                    y: footerY, maxWidth: maxWidth, align: 'left', margin: margin
                });
                this.drawText(String(pageCount), {
                    page, font: regular, size: 9, color: rgb(0.5, 0.5, 0.5), 
                    y: footerY, maxWidth: maxWidth, align: 'right', margin: margin
                });
            },

            /**
             * Generates a PDF for a single file and returns its ArrayBuffer.
             * This function now loads the fonts based on settings.
             */
            generatePdfBuffer: async function(markdownContent, finalSettings, options = {}) {
                const { PDFDocument } = PDFLib;
                
                const pdfDoc = await PDFDocument.create();
                pdfDoc.registerFontkit(fontkit);
                // PDF metadata for professional output
                try {
                    if (finalSettings && finalSettings.courseTitle) pdfDoc.setTitle(String(finalSettings.courseTitle));
                    if (finalSettings && finalSettings.instructorName) pdfDoc.setAuthor(String(finalSettings.instructorName));
                    if (finalSettings && finalSettings.footerText) pdfDoc.setSubject(String(finalSettings.footerText));
                    pdfDoc.setCreator('mdMan');
                    pdfDoc.setProducer('mdMan (pdf-lib)');
                    pdfDoc.setCreationDate(new Date());
                } catch (metaErr) { /* ignore metadata errors */ }
                
                // Load fonts based on the finalSettings.fontFamily key
                const fonts = await this.loadFonts(pdfDoc, finalSettings.fontFamily);
                
                await this.renderMdToPdfDoc(pdfDoc, markdownContent, finalSettings, fonts, options);

                return await pdfDoc.save();
            },

            // --- Main Batch Process (Rewritten for pdf-lib) ---
            processBatch: async function() {
                this.dom.generateBatch.prop('disabled', true).addClass('opacity-50');
                this.dom.batchButtonText.text('Processing... Please Wait');
                this.dom.errorMessage.addClass('hidden');
                this.dom.progressArea.removeClass('hidden');
                this.dom.progressBar.css('width', '0%');
                this.dom.progressText.text('0%');
                this.dom.globalStatus.text('Initializing batch...');

                const globalSettings = this.getGlobalSettings();
                const processingMode = $('#processing-mode').val();
                let filesProcessed = 0;
                let filesFailed = 0;
                
                this.fileQueue.forEach(file => this.updateFileStatus(file.id, 'waiting'));
                
                // --- LOGIC PATH: .ZIP (Multiple Files) ---
                if (processingMode === 'zip') {
                    // In zip mode, TOC setting is ignored, and "00 -" files are processed normally.
                    const zip = new JSZip();
                    
                    for (const file of this.fileQueue) {
                        try {
                            console.log(`Starting processing of ${file.name}`);
                            this.dom.globalStatus.text(`Processing: ${file.name}...`);
                            this.updateFileStatus(file.id, 'processing');

                            const finalSettings = { ...globalSettings, ...(file.overrideSettings || {}) };

                            // Check if this is a TOC file (for zip, this just means skipping the title page)
                            const isTocFile = globalSettings.includeToc && file.name.startsWith('00 -');

                            console.log(`Generating PDF for ${file.name}...`);
                            const pdfBytes = await this.generatePdfBuffer(file.content, finalSettings, { isToc: isTocFile });
                            
                            const pdfName = file.name.replace(/\.md$|\.markdown$/, '.pdf');
                            zip.file(pdfName, pdfBytes);

                            console.log(`Completed processing ${file.name}`);
                            this.updateFileStatus(file.id, 'done');
                            filesProcessed++;

                        } catch (err) {
                            console.error(`Failed to process ${file.name}:`, err);
                            this.updateFileStatus(file.id, 'error', err.message);
                            filesFailed++;
                        }
                        
                        const percent = Math.round(((filesProcessed + filesFailed) / this.fileQueue.length) * 100);
                        this.dom.progressBar.css('width', `${percent}%`);
                        this.dom.progressText.text(`${percent}%`);
                    }

                    // Finalize Zip
                    if (filesProcessed > 0) {
                        this.dom.globalStatus.text('Compressing files into .zip...');
                        try {
                            const zipBlob = await zip.generateAsync({ type: 'blob' });
                            saveAs(zipBlob, `${globalSettings.zipFilename}.zip`);
                            this.dom.globalStatus.text(`Batch complete! ${filesProcessed} files processed, ${filesFailed} failed.`);
                        } catch (err) {
                            this.showGlobalError('Failed to create .zip file. ' + err.message);
                            console.error(err);
                        }
                    } else if (filesFailed > 0) {
                         this.showGlobalError('All files failed to process. Check console for errors.');
                    } else {
                        this.showGlobalError('No files were processed.');
                    }
                } 
                
                // --- LOGIC PATH: SINGLE COMBINED PDF ---
                else if (processingMode === 'single') {
                    this.dom.globalStatus.text('Initializing combined PDF...');
                    const { PDFDocument } = PDFLib;
                    
                    try {
                        const combinedDoc = await PDFDocument.create();
                        combinedDoc.registerFontkit(fontkit);
                        
                        // Load fonts ONCE based on GLOBAL settings.
                        // Note: This means per-file font overrides won't work in combined mode.
                        this.dom.globalStatus.text('Loading fonts...');
                        const fonts = await this.loadFonts(combinedDoc, globalSettings.fontFamily);

                        // === NEW TOC LOGIC ===
                        let tocFile = null;
                        let contentFiles = [...this.fileQueue];
                        
                        if (globalSettings.includeToc) {
                            tocFile = contentFiles.find(f => f.name.startsWith('00 -'));
                            if (tocFile) {
                                contentFiles = contentFiles.filter(f => f.id !== tocFile.id);
                                
                                // 1. Render TOC file FIRST
                                this.dom.globalStatus.text(`Appending TOC: ${tocFile.name}...`);
                                this.updateFileStatus(tocFile.id, 'processing');
                                // Use global settings, but mark as TOC
                                await this.renderMdToPdfDoc(combinedDoc, tocFile.content, globalSettings, fonts, { isToc: true });
                                this.updateFileStatus(tocFile.id, 'done');
                                filesProcessed++;
                            }
                        }
                        // === END NEW TOC LOGIC ===

                        // 3. Loop and append remaining content files
                        let isFirstContentFile = true;
                        for (const file of contentFiles) {
                            // Per-file overrides are ignored in single mode for font consistency
                            const finalSettings = { ...globalSettings, ...(file.overrideSettings || {}), fontFamily: globalSettings.fontFamily };
                            
                            try {
                                console.log(`Starting single PDF processing of ${file.name}`);
                                this.dom.globalStatus.text(`Appending: ${file.name}...`);
                                this.updateFileStatus(file.id, 'processing');
                                
                                // Skip cover page for all files after the first one
                                const skipCoverPage = isFirstContentFile ? false : true;
                                console.log(`Rendering ${file.name} with skipCoverPage: ${skipCoverPage}`);
                                await this.renderMdToPdfDoc(combinedDoc, file.content, finalSettings, fonts, { 
                                    isToc: false, 
                                    skipCoverPage: skipCoverPage 
                                });
                                
                                isFirstContentFile = false;
                                console.log(`Completed single PDF processing of ${file.name}`);
                                this.updateFileStatus(file.id, 'done');
                                filesProcessed++;
                            } catch (err) {
                                console.error(`Failed to append ${file.name}:`, err);
                                this.updateFileStatus(file.id, 'error', err.message);
                                filesFailed++;
                            }
                            
                            const percent = Math.round(((filesProcessed + filesFailed) / this.fileQueue.length) * 100);
                            this.dom.progressBar.css('width', `${percent}%`);
                            this.dom.progressText.text(`${percent}%`);
                        }
                        
                        // 4. Save the combined doc
                        if (filesProcessed > 0) {
                            this.dom.globalStatus.text('Saving combined PDF...');
                            const pdfBytes = await combinedDoc.save();
                            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                            const pdfName = `${globalSettings.zipFilename}.pdf`;
                            saveAs(blob, pdfName);
                            this.dom.globalStatus.text(`Batch complete! ${filesProcessed} files combined, ${filesFailed} failed.`);
                        } else if (filesFailed > 0) {
                             this.showGlobalError('All files failed to process. Check console for errors.');
                        } else {
                             this.showGlobalError('No files were processed.');
                        }

                    } catch (err) {
                        this.showGlobalError('Failed to create combined PDF. ' + err.message);
                        console.error(err);
                    }
                }

                // 6. Re-enable UI
                this.dom.generateBatch.prop('disabled', false).removeClass('opacity-50');
                this.dom.batchButtonText.text(`Start Batch Process (${this.fileQueue.length} files)`);
            }
        };

        // --- Document Ready ---
        $(document).ready(function() {
            // Check for dependencies
            if (typeof $ === 'undefined' || 
                typeof marked === 'undefined' || 
                typeof PDFLib === 'undefined' || 
                typeof fontkit === 'undefined' || 
                typeof JSZip === 'undefined' || 
                typeof saveAs === 'undefined') {
                
                console.error("One or more critical libraries failed to load. App cannot start.");
                $('body').html('<h1 style="color: red; text-align: center; margin-top: 50px;">Error: A required library (jQuery, marked, pdf-lib, fontkit, JSZip, or FileSaver) failed to load. Check your internet connection or browser console.</h1>');
                return;
            }
            FormatterApp.init();
        });
    </script>
</body>
</html>